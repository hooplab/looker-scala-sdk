/**
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.Error
import io.swagger.client.model.Group
import io.swagger.client.model.ModelSet
import io.swagger.client.model.Permission
import io.swagger.client.model.PermissionSet
import io.swagger.client.model.Role
import io.swagger.client.model.User
import io.swagger.client.model.ValidationError
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class RoleApi(
  val defBasePath: String = "https://hoopla.eu.looker.com:19999/api/3.0",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new RoleApiAsyncHelper(client, config)

  /**
   * Get All Model Sets
   * ### Get information about all model sets. 
   *
   * @param fields Requested fields. (optional)
   * @return List[ModelSet]
   */
  def allModelSets(fields: Option[String] = None): Option[List[ModelSet]] = {
    val await = Try(Await.result(allModelSetsAsync(fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Model Sets asynchronously
   * ### Get information about all model sets. 
   *
   * @param fields Requested fields. (optional)
   * @return Future(List[ModelSet])
   */
  def allModelSetsAsync(fields: Option[String] = None): Future[List[ModelSet]] = {
      helper.allModelSets(fields)
  }

  /**
   * Get All Permission Sets
   * ### Get information about all permission sets. 
   *
   * @param fields Requested fields. (optional)
   * @return List[PermissionSet]
   */
  def allPermissionSets(fields: Option[String] = None): Option[List[PermissionSet]] = {
    val await = Try(Await.result(allPermissionSetsAsync(fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Permission Sets asynchronously
   * ### Get information about all permission sets. 
   *
   * @param fields Requested fields. (optional)
   * @return Future(List[PermissionSet])
   */
  def allPermissionSetsAsync(fields: Option[String] = None): Future[List[PermissionSet]] = {
      helper.allPermissionSets(fields)
  }

  /**
   * Get All Permissions
   * ### Get all supported permissions. 
   *
   * @return List[Permission]
   */
  def allPermissions(): Option[List[Permission]] = {
    val await = Try(Await.result(allPermissionsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Permissions asynchronously
   * ### Get all supported permissions. 
   *
   * @return Future(List[Permission])
   */
  def allPermissionsAsync(): Future[List[Permission]] = {
      helper.allPermissions()
  }

  /**
   * Get All Roles
   * ### Get information about all roles. 
   *
   * @param fields Requested fields. (optional)
   * @param ids Optional list of ids to get specific roles. (optional)
   * @return List[Role]
   */
  def allRoles(fields: Option[String] = None, ids: Option[List[Long]] = None): Option[List[Role]] = {
    val await = Try(Await.result(allRolesAsync(fields, ids), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Roles asynchronously
   * ### Get information about all roles. 
   *
   * @param fields Requested fields. (optional)
   * @param ids Optional list of ids to get specific roles. (optional)
   * @return Future(List[Role])
   */
  def allRolesAsync(fields: Option[String] = None, ids: Option[List[Long]] = None): Future[List[Role]] = {
      helper.allRoles(fields, ids)
  }

  /**
   * Create Model Set
   * ### Create a model set with the specified information. Model sets are used by Roles. 
   *
   * @param body ModelSet (optional)
   * @return ModelSet
   */
  def createModelSet(body: Option[ModelSet] = None): Option[ModelSet] = {
    val await = Try(Await.result(createModelSetAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Model Set asynchronously
   * ### Create a model set with the specified information. Model sets are used by Roles. 
   *
   * @param body ModelSet (optional)
   * @return Future(ModelSet)
   */
  def createModelSetAsync(body: Option[ModelSet] = None): Future[ModelSet] = {
      helper.createModelSet(body)
  }

  /**
   * Create Permission Set
   * ### Create a permission set with the specified information. Permission sets are used by Roles. 
   *
   * @param body Permission Set (optional)
   * @return PermissionSet
   */
  def createPermissionSet(body: Option[PermissionSet] = None): Option[PermissionSet] = {
    val await = Try(Await.result(createPermissionSetAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Permission Set asynchronously
   * ### Create a permission set with the specified information. Permission sets are used by Roles. 
   *
   * @param body Permission Set (optional)
   * @return Future(PermissionSet)
   */
  def createPermissionSetAsync(body: Option[PermissionSet] = None): Future[PermissionSet] = {
      helper.createPermissionSet(body)
  }

  /**
   * Create Role
   * ### Create a role with the specified information. 
   *
   * @param body Role (optional)
   * @return Role
   */
  def createRole(body: Option[Role] = None): Option[Role] = {
    val await = Try(Await.result(createRoleAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Role asynchronously
   * ### Create a role with the specified information. 
   *
   * @param body Role (optional)
   * @return Future(Role)
   */
  def createRoleAsync(body: Option[Role] = None): Future[Role] = {
      helper.createRole(body)
  }

  /**
   * Delete Model Set
   * ### Delete the model set with a specific id. 
   *
   * @param modelSetId id of model set 
   * @return String
   */
  def deleteModelSet(modelSetId: Long): Option[String] = {
    val await = Try(Await.result(deleteModelSetAsync(modelSetId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Model Set asynchronously
   * ### Delete the model set with a specific id. 
   *
   * @param modelSetId id of model set 
   * @return Future(String)
   */
  def deleteModelSetAsync(modelSetId: Long): Future[String] = {
      helper.deleteModelSet(modelSetId)
  }

  /**
   * Delete Permission Set
   * ### Delete the permission set with a specific id. 
   *
   * @param permissionSetId Id of permission set 
   * @return String
   */
  def deletePermissionSet(permissionSetId: Long): Option[String] = {
    val await = Try(Await.result(deletePermissionSetAsync(permissionSetId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Permission Set asynchronously
   * ### Delete the permission set with a specific id. 
   *
   * @param permissionSetId Id of permission set 
   * @return Future(String)
   */
  def deletePermissionSetAsync(permissionSetId: Long): Future[String] = {
      helper.deletePermissionSet(permissionSetId)
  }

  /**
   * Delete Role
   * ### Delete the role with a specific id. 
   *
   * @param roleId id of role 
   * @return String
   */
  def deleteRole(roleId: Long): Option[String] = {
    val await = Try(Await.result(deleteRoleAsync(roleId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Role asynchronously
   * ### Delete the role with a specific id. 
   *
   * @param roleId id of role 
   * @return Future(String)
   */
  def deleteRoleAsync(roleId: Long): Future[String] = {
      helper.deleteRole(roleId)
  }

  /**
   * Get Model Set
   * ### Get information about the model set with a specific id. 
   *
   * @param modelSetId Id of model set 
   * @param fields Requested fields. (optional)
   * @return ModelSet
   */
  def modelSet(modelSetId: Long, fields: Option[String] = None): Option[ModelSet] = {
    val await = Try(Await.result(modelSetAsync(modelSetId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Model Set asynchronously
   * ### Get information about the model set with a specific id. 
   *
   * @param modelSetId Id of model set 
   * @param fields Requested fields. (optional)
   * @return Future(ModelSet)
   */
  def modelSetAsync(modelSetId: Long, fields: Option[String] = None): Future[ModelSet] = {
      helper.modelSet(modelSetId, fields)
  }

  /**
   * Get Permission Set
   * ### Get information about the permission set with a specific id. 
   *
   * @param permissionSetId Id of permission set 
   * @param fields Requested fields. (optional)
   * @return PermissionSet
   */
  def permissionSet(permissionSetId: Long, fields: Option[String] = None): Option[PermissionSet] = {
    val await = Try(Await.result(permissionSetAsync(permissionSetId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Permission Set asynchronously
   * ### Get information about the permission set with a specific id. 
   *
   * @param permissionSetId Id of permission set 
   * @param fields Requested fields. (optional)
   * @return Future(PermissionSet)
   */
  def permissionSetAsync(permissionSetId: Long, fields: Option[String] = None): Future[PermissionSet] = {
      helper.permissionSet(permissionSetId, fields)
  }

  /**
   * Get Role
   * ### Get information about the role with a specific id. 
   *
   * @param roleId id of role 
   * @return Role
   */
  def role(roleId: Long): Option[Role] = {
    val await = Try(Await.result(roleAsync(roleId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Role asynchronously
   * ### Get information about the role with a specific id. 
   *
   * @param roleId id of role 
   * @return Future(Role)
   */
  def roleAsync(roleId: Long): Future[Role] = {
      helper.role(roleId)
  }

  /**
   * Get Role Groups
   * ### Get information about all the groups with the role that has a specific id. 
   *
   * @param roleId id of role 
   * @param fields Requested fields. (optional)
   * @return List[Group]
   */
  def roleGroups(roleId: Long, fields: Option[String] = None): Option[List[Group]] = {
    val await = Try(Await.result(roleGroupsAsync(roleId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Role Groups asynchronously
   * ### Get information about all the groups with the role that has a specific id. 
   *
   * @param roleId id of role 
   * @param fields Requested fields. (optional)
   * @return Future(List[Group])
   */
  def roleGroupsAsync(roleId: Long, fields: Option[String] = None): Future[List[Group]] = {
      helper.roleGroups(roleId, fields)
  }

  /**
   * Get Role Users
   * ### Get information about all the users with the role that has a specific id. 
   *
   * @param roleId id of user 
   * @param fields Requested fields. (optional)
   * @param directAssociationOnly Get only users associated directly with the role: exclude those only associated through groups. (optional)
   * @return List[User]
   */
  def roleUsers(roleId: Long, fields: Option[String] = None, directAssociationOnly: Option[Boolean] = None): Option[List[User]] = {
    val await = Try(Await.result(roleUsersAsync(roleId, fields, directAssociationOnly), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Role Users asynchronously
   * ### Get information about all the users with the role that has a specific id. 
   *
   * @param roleId id of user 
   * @param fields Requested fields. (optional)
   * @param directAssociationOnly Get only users associated directly with the role: exclude those only associated through groups. (optional)
   * @return Future(List[User])
   */
  def roleUsersAsync(roleId: Long, fields: Option[String] = None, directAssociationOnly: Option[Boolean] = None): Future[List[User]] = {
      helper.roleUsers(roleId, fields, directAssociationOnly)
  }

  /**
   * Update Role Groups
   * ### Set all groups for a role, removing all existing group associations from that role. 
   *
   * @param roleId Id of Role 
   * @param body Array of Group Ids 
   * @return List[Group]
   */
  def setRoleGroups(roleId: Long, body: List[Long]): Option[List[Group]] = {
    val await = Try(Await.result(setRoleGroupsAsync(roleId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Role Groups asynchronously
   * ### Set all groups for a role, removing all existing group associations from that role. 
   *
   * @param roleId Id of Role 
   * @param body Array of Group Ids 
   * @return Future(List[Group])
   */
  def setRoleGroupsAsync(roleId: Long, body: List[Long]): Future[List[Group]] = {
      helper.setRoleGroups(roleId, body)
  }

  /**
   * Update Role Users
   * ### Set all the users of the role with a specific id. 
   *
   * @param roleId id of role 
   * @param body array of user ids for role 
   * @return List[User]
   */
  def setRoleUsers(roleId: Long, body: List[Long]): Option[List[User]] = {
    val await = Try(Await.result(setRoleUsersAsync(roleId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Role Users asynchronously
   * ### Set all the users of the role with a specific id. 
   *
   * @param roleId id of role 
   * @param body array of user ids for role 
   * @return Future(List[User])
   */
  def setRoleUsersAsync(roleId: Long, body: List[Long]): Future[List[User]] = {
      helper.setRoleUsers(roleId, body)
  }

  /**
   * Update Model Set
   * ### Update information about the model set with a specific id. 
   *
   * @param modelSetId id of model set 
   * @param body ModelSet 
   * @return ModelSet
   */
  def updateModelSet(modelSetId: Long, body: ModelSet): Option[ModelSet] = {
    val await = Try(Await.result(updateModelSetAsync(modelSetId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Model Set asynchronously
   * ### Update information about the model set with a specific id. 
   *
   * @param modelSetId id of model set 
   * @param body ModelSet 
   * @return Future(ModelSet)
   */
  def updateModelSetAsync(modelSetId: Long, body: ModelSet): Future[ModelSet] = {
      helper.updateModelSet(modelSetId, body)
  }

  /**
   * Update Permission Set
   * ### Update information about the permission set with a specific id. 
   *
   * @param permissionSetId id of permission set 
   * @param body Permission Set 
   * @return PermissionSet
   */
  def updatePermissionSet(permissionSetId: Long, body: PermissionSet): Option[PermissionSet] = {
    val await = Try(Await.result(updatePermissionSetAsync(permissionSetId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Permission Set asynchronously
   * ### Update information about the permission set with a specific id. 
   *
   * @param permissionSetId id of permission set 
   * @param body Permission Set 
   * @return Future(PermissionSet)
   */
  def updatePermissionSetAsync(permissionSetId: Long, body: PermissionSet): Future[PermissionSet] = {
      helper.updatePermissionSet(permissionSetId, body)
  }

  /**
   * Update Role
   * ### Update information about the role with a specific id. 
   *
   * @param roleId id of role 
   * @param body Role 
   * @return Role
   */
  def updateRole(roleId: Long, body: Role): Option[Role] = {
    val await = Try(Await.result(updateRoleAsync(roleId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Role asynchronously
   * ### Update information about the role with a specific id. 
   *
   * @param roleId id of role 
   * @param body Role 
   * @return Future(Role)
   */
  def updateRoleAsync(roleId: Long, body: Role): Future[Role] = {
      helper.updateRole(roleId, body)
  }

}

class RoleApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def allModelSets(fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[ModelSet]]): Future[List[ModelSet]] = {
    // create path and map variables
    val path = (addFmt("/model_sets"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allPermissionSets(fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[PermissionSet]]): Future[List[PermissionSet]] = {
    // create path and map variables
    val path = (addFmt("/permission_sets"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allPermissions()(implicit reader: ClientResponseReader[List[Permission]]): Future[List[Permission]] = {
    // create path and map variables
    val path = (addFmt("/permissions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allRoles(fields: Option[String] = None,
    ids: Option[List[Long]] = None
    )(implicit reader: ClientResponseReader[List[Role]]): Future[List[Role]] = {
    // create path and map variables
    val path = (addFmt("/roles"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    ids match {
      case Some(param) => queryParams += "ids" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createModelSet(body: Option[ModelSet] = None
    )(implicit reader: ClientResponseReader[ModelSet], writer: RequestWriter[Option[ModelSet]]): Future[ModelSet] = {
    // create path and map variables
    val path = (addFmt("/model_sets"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createPermissionSet(body: Option[PermissionSet] = None
    )(implicit reader: ClientResponseReader[PermissionSet], writer: RequestWriter[Option[PermissionSet]]): Future[PermissionSet] = {
    // create path and map variables
    val path = (addFmt("/permission_sets"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createRole(body: Option[Role] = None
    )(implicit reader: ClientResponseReader[Role], writer: RequestWriter[Option[Role]]): Future[Role] = {
    // create path and map variables
    val path = (addFmt("/roles"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteModelSet(modelSetId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/model_sets/{model_set_id}")
      replaceAll("\\{" + "model_set_id" + "\\}", modelSetId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deletePermissionSet(permissionSetId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/permission_sets/{permission_set_id}")
      replaceAll("\\{" + "permission_set_id" + "\\}", permissionSetId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteRole(roleId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def modelSet(modelSetId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[ModelSet]): Future[ModelSet] = {
    // create path and map variables
    val path = (addFmt("/model_sets/{model_set_id}")
      replaceAll("\\{" + "model_set_id" + "\\}", modelSetId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def permissionSet(permissionSetId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[PermissionSet]): Future[PermissionSet] = {
    // create path and map variables
    val path = (addFmt("/permission_sets/{permission_set_id}")
      replaceAll("\\{" + "permission_set_id" + "\\}", permissionSetId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def role(roleId: Long)(implicit reader: ClientResponseReader[Role]): Future[Role] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def roleGroups(roleId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Group]]): Future[List[Group]] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}/groups")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def roleUsers(roleId: Long,
    fields: Option[String] = None,
    directAssociationOnly: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[List[User]]): Future[List[User]] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}/users")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    directAssociationOnly match {
      case Some(param) => queryParams += "direct_association_only" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setRoleGroups(roleId: Long,
    body: List[Long])(implicit reader: ClientResponseReader[List[Group]], writer: RequestWriter[List[Long]]): Future[List[Group]] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}/groups")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setRoleUsers(roleId: Long,
    body: List[Long])(implicit reader: ClientResponseReader[List[User]], writer: RequestWriter[List[Long]]): Future[List[User]] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}/users")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateModelSet(modelSetId: Long,
    body: ModelSet)(implicit reader: ClientResponseReader[ModelSet], writer: RequestWriter[ModelSet]): Future[ModelSet] = {
    // create path and map variables
    val path = (addFmt("/model_sets/{model_set_id}")
      replaceAll("\\{" + "model_set_id" + "\\}", modelSetId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling RoleApi->updateModelSet")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updatePermissionSet(permissionSetId: Long,
    body: PermissionSet)(implicit reader: ClientResponseReader[PermissionSet], writer: RequestWriter[PermissionSet]): Future[PermissionSet] = {
    // create path and map variables
    val path = (addFmt("/permission_sets/{permission_set_id}")
      replaceAll("\\{" + "permission_set_id" + "\\}", permissionSetId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling RoleApi->updatePermissionSet")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateRole(roleId: Long,
    body: Role)(implicit reader: ClientResponseReader[Role], writer: RequestWriter[Role]): Future[Role] = {
    // create path and map variables
    val path = (addFmt("/roles/{role_id}")
      replaceAll("\\{" + "role_id" + "\\}", roleId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling RoleApi->updateRole")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
