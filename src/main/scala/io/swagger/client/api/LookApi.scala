/**
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.Error
import io.swagger.client.model.Look
import io.swagger.client.model.LookWithQuery
import io.swagger.client.model.ValidationError
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class LookApi(
  val defBasePath: String = "https://hoopla.eu.looker.com:19999/api/3.0",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new LookApiAsyncHelper(client, config)

  /**
   * Get All Looks
   * ### Get all the looks.
   *
   * @param fields Requested fields. (optional)
   * @return List[Look]
   */
  def allLooks(fields: Option[String] = None): Option[List[Look]] = {
    val await = Try(Await.result(allLooksAsync(fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Looks asynchronously
   * ### Get all the looks.
   *
   * @param fields Requested fields. (optional)
   * @return Future(List[Look])
   */
  def allLooksAsync(fields: Option[String] = None): Future[List[Look]] = {
      helper.allLooks(fields)
  }

  /**
   * Create Look
   * ### Create a Look with specified information.
   *
   * @param body Look (optional)
   * @param fields Requested fields. (optional)
   * @return LookWithQuery
   */
  def createLook(body: Option[LookWithQuery] = None, fields: Option[String] = None): Option[LookWithQuery] = {
    val await = Try(Await.result(createLookAsync(body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Look asynchronously
   * ### Create a Look with specified information.
   *
   * @param body Look (optional)
   * @param fields Requested fields. (optional)
   * @return Future(LookWithQuery)
   */
  def createLookAsync(body: Option[LookWithQuery] = None, fields: Option[String] = None): Future[LookWithQuery] = {
      helper.createLook(body, fields)
  }

  /**
   * Delete Look
   * ### Delete the look with a specific id.
   *
   * @param lookId Id of look 
   * @return String
   */
  def deleteLook(lookId: Long): Option[String] = {
    val await = Try(Await.result(deleteLookAsync(lookId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Look asynchronously
   * ### Delete the look with a specific id.
   *
   * @param lookId Id of look 
   * @return Future(String)
   */
  def deleteLookAsync(lookId: Long): Future[String] = {
      helper.deleteLook(lookId)
  }

  /**
   * Get Look
   * ### Get a Look.  Return detailed information about the Look and its associated Query.  
   *
   * @param lookId Id of look 
   * @param fields Requested fields. (optional)
   * @return LookWithQuery
   */
  def look(lookId: Long, fields: Option[String] = None): Option[LookWithQuery] = {
    val await = Try(Await.result(lookAsync(lookId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Look asynchronously
   * ### Get a Look.  Return detailed information about the Look and its associated Query.  
   *
   * @param lookId Id of look 
   * @param fields Requested fields. (optional)
   * @return Future(LookWithQuery)
   */
  def lookAsync(lookId: Long, fields: Option[String] = None): Future[LookWithQuery] = {
      helper.look(lookId, fields)
  }

  /**
   * Run Look
   * ### Run a Look.  Runs a given look&#39;s query and returns the results in the requested format.  Supported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
   *
   * @param lookId Id of look 
   * @param resultFormat Format of result 
   * @param limit Row limit (may override the limit in the saved query). (optional)
   * @param applyFormatting Apply model-specified formatting to each result. (optional)
   * @param applyVis Apply visualization options to results. (optional)
   * @param cache Get results from cache if available. (optional)
   * @param imageWidth Render width for image formats. (optional)
   * @param imageHeight Render height for image formats. (optional)
   * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
   * @param forceProduction Force use of production models even if the user is in development mode. (optional)
   * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
   * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
   * @param rebuildPdts Rebuild PDTS used in query. (optional)
   * @param serverTableCalcs Perform table calculations on query results (optional)
   * @return String
   */
  def runLook(lookId: Long, resultFormat: String, limit: Option[Long] = None, applyFormatting: Option[Boolean] = None, applyVis: Option[Boolean] = None, cache: Option[Boolean] = None, imageWidth: Option[Long] = None, imageHeight: Option[Long] = None, generateDrillLinks: Option[Boolean] = None, forceProduction: Option[Boolean] = None, cacheOnly: Option[Boolean] = None, pathPrefix: Option[String] = None, rebuildPdts: Option[Boolean] = None, serverTableCalcs: Option[Boolean] = None): Option[String] = {
    val await = Try(Await.result(runLookAsync(lookId, resultFormat, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run Look asynchronously
   * ### Run a Look.  Runs a given look&#39;s query and returns the results in the requested format.  Supported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
   *
   * @param lookId Id of look 
   * @param resultFormat Format of result 
   * @param limit Row limit (may override the limit in the saved query). (optional)
   * @param applyFormatting Apply model-specified formatting to each result. (optional)
   * @param applyVis Apply visualization options to results. (optional)
   * @param cache Get results from cache if available. (optional)
   * @param imageWidth Render width for image formats. (optional)
   * @param imageHeight Render height for image formats. (optional)
   * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
   * @param forceProduction Force use of production models even if the user is in development mode. (optional)
   * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
   * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
   * @param rebuildPdts Rebuild PDTS used in query. (optional)
   * @param serverTableCalcs Perform table calculations on query results (optional)
   * @return Future(String)
   */
  def runLookAsync(lookId: Long, resultFormat: String, limit: Option[Long] = None, applyFormatting: Option[Boolean] = None, applyVis: Option[Boolean] = None, cache: Option[Boolean] = None, imageWidth: Option[Long] = None, imageHeight: Option[Long] = None, generateDrillLinks: Option[Boolean] = None, forceProduction: Option[Boolean] = None, cacheOnly: Option[Boolean] = None, pathPrefix: Option[String] = None, rebuildPdts: Option[Boolean] = None, serverTableCalcs: Option[Boolean] = None): Future[String] = {
      helper.runLook(lookId, resultFormat, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs)
  }

  /**
   * Search Looks
   * Search looks.
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param limit Number of results to return. (used with offset and takes priority over page and per_page) (optional)
   * @param offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page) (optional)
   * @param sorts Fields to sort by. (optional)
   * @param title Match Look title. (optional)
   * @param description Match Look description. (optional)
   * @param contentFavoriteId Match content favorite id (optional)
   * @param spaceId Filter on a particular space. (optional)
   * @param userId Filter on dashboards created by a particular user. (optional)
   * @param viewCount Filter on a particular value of view_count (optional)
   * @return List[Look]
   */
  def searchLooks(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, limit: Option[Long] = None, offset: Option[Long] = None, sorts: Option[String] = None, title: Option[String] = None, description: Option[String] = None, contentFavoriteId: Option[Long] = None, spaceId: Option[String] = None, userId: Option[String] = None, viewCount: Option[String] = None): Option[List[Look]] = {
    val await = Try(Await.result(searchLooksAsync(fields, page, perPage, limit, offset, sorts, title, description, contentFavoriteId, spaceId, userId, viewCount), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Search Looks asynchronously
   * Search looks.
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param limit Number of results to return. (used with offset and takes priority over page and per_page) (optional)
   * @param offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page) (optional)
   * @param sorts Fields to sort by. (optional)
   * @param title Match Look title. (optional)
   * @param description Match Look description. (optional)
   * @param contentFavoriteId Match content favorite id (optional)
   * @param spaceId Filter on a particular space. (optional)
   * @param userId Filter on dashboards created by a particular user. (optional)
   * @param viewCount Filter on a particular value of view_count (optional)
   * @return Future(List[Look])
   */
  def searchLooksAsync(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, limit: Option[Long] = None, offset: Option[Long] = None, sorts: Option[String] = None, title: Option[String] = None, description: Option[String] = None, contentFavoriteId: Option[Long] = None, spaceId: Option[String] = None, userId: Option[String] = None, viewCount: Option[String] = None): Future[List[Look]] = {
      helper.searchLooks(fields, page, perPage, limit, offset, sorts, title, description, contentFavoriteId, spaceId, userId, viewCount)
  }

  /**
   * Update Look
   * ### Update the Look with a specific id.
   *
   * @param lookId Id of look 
   * @param body Look 
   * @param fields Requested fields. (optional)
   * @return LookWithQuery
   */
  def updateLook(lookId: Long, body: LookWithQuery, fields: Option[String] = None): Option[LookWithQuery] = {
    val await = Try(Await.result(updateLookAsync(lookId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Look asynchronously
   * ### Update the Look with a specific id.
   *
   * @param lookId Id of look 
   * @param body Look 
   * @param fields Requested fields. (optional)
   * @return Future(LookWithQuery)
   */
  def updateLookAsync(lookId: Long, body: LookWithQuery, fields: Option[String] = None): Future[LookWithQuery] = {
      helper.updateLook(lookId, body, fields)
  }

}

class LookApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def allLooks(fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Look]]): Future[List[Look]] = {
    // create path and map variables
    val path = (addFmt("/looks"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createLook(body: Option[LookWithQuery] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[LookWithQuery], writer: RequestWriter[Option[LookWithQuery]]): Future[LookWithQuery] = {
    // create path and map variables
    val path = (addFmt("/looks"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteLook(lookId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/looks/{look_id}")
      replaceAll("\\{" + "look_id" + "\\}", lookId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def look(lookId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[LookWithQuery]): Future[LookWithQuery] = {
    // create path and map variables
    val path = (addFmt("/looks/{look_id}")
      replaceAll("\\{" + "look_id" + "\\}", lookId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def runLook(lookId: Long,
    resultFormat: String,
    limit: Option[Long] = None,
    applyFormatting: Option[Boolean] = None,
    applyVis: Option[Boolean] = None,
    cache: Option[Boolean] = None,
    imageWidth: Option[Long] = None,
    imageHeight: Option[Long] = None,
    generateDrillLinks: Option[Boolean] = None,
    forceProduction: Option[Boolean] = None,
    cacheOnly: Option[Boolean] = None,
    pathPrefix: Option[String] = None,
    rebuildPdts: Option[Boolean] = None,
    serverTableCalcs: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/looks/{look_id}/run/{result_format}")
      replaceAll("\\{" + "look_id" + "\\}", lookId.toString)
      replaceAll("\\{" + "result_format" + "\\}", resultFormat.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (resultFormat == null) throw new Exception("Missing required parameter 'resultFormat' when calling LookApi->runLook")

    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    applyFormatting match {
      case Some(param) => queryParams += "apply_formatting" -> param.toString
      case _ => queryParams
    }
    applyVis match {
      case Some(param) => queryParams += "apply_vis" -> param.toString
      case _ => queryParams
    }
    cache match {
      case Some(param) => queryParams += "cache" -> param.toString
      case _ => queryParams
    }
    imageWidth match {
      case Some(param) => queryParams += "image_width" -> param.toString
      case _ => queryParams
    }
    imageHeight match {
      case Some(param) => queryParams += "image_height" -> param.toString
      case _ => queryParams
    }
    generateDrillLinks match {
      case Some(param) => queryParams += "generate_drill_links" -> param.toString
      case _ => queryParams
    }
    forceProduction match {
      case Some(param) => queryParams += "force_production" -> param.toString
      case _ => queryParams
    }
    cacheOnly match {
      case Some(param) => queryParams += "cache_only" -> param.toString
      case _ => queryParams
    }
    pathPrefix match {
      case Some(param) => queryParams += "path_prefix" -> param.toString
      case _ => queryParams
    }
    rebuildPdts match {
      case Some(param) => queryParams += "rebuild_pdts" -> param.toString
      case _ => queryParams
    }
    serverTableCalcs match {
      case Some(param) => queryParams += "server_table_calcs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def searchLooks(fields: Option[String] = None,
    page: Option[Long] = None,
    perPage: Option[Long] = None,
    limit: Option[Long] = None,
    offset: Option[Long] = None,
    sorts: Option[String] = None,
    title: Option[String] = None,
    description: Option[String] = None,
    contentFavoriteId: Option[Long] = None,
    spaceId: Option[String] = None,
    userId: Option[String] = None,
    viewCount: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Look]]): Future[List[Look]] = {
    // create path and map variables
    val path = (addFmt("/looks/search"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    perPage match {
      case Some(param) => queryParams += "per_page" -> param.toString
      case _ => queryParams
    }
    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }
    title match {
      case Some(param) => queryParams += "title" -> param.toString
      case _ => queryParams
    }
    description match {
      case Some(param) => queryParams += "description" -> param.toString
      case _ => queryParams
    }
    contentFavoriteId match {
      case Some(param) => queryParams += "content_favorite_id" -> param.toString
      case _ => queryParams
    }
    spaceId match {
      case Some(param) => queryParams += "space_id" -> param.toString
      case _ => queryParams
    }
    userId match {
      case Some(param) => queryParams += "user_id" -> param.toString
      case _ => queryParams
    }
    viewCount match {
      case Some(param) => queryParams += "view_count" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateLook(lookId: Long,
    body: LookWithQuery,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[LookWithQuery], writer: RequestWriter[LookWithQuery]): Future[LookWithQuery] = {
    // create path and map variables
    val path = (addFmt("/looks/{look_id}")
      replaceAll("\\{" + "look_id" + "\\}", lookId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling LookApi->updateLook")
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
