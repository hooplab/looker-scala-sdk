/**
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.Error
import io.swagger.client.model.GitBranch
import io.swagger.client.model.GitConnectionTest
import io.swagger.client.model.GitConnectionTestResult
import io.swagger.client.model.Project
import io.swagger.client.model.ProjectFile
import io.swagger.client.model.ProjectValidation
import io.swagger.client.model.ProjectValidationCache
import io.swagger.client.model.ProjectWorkspace
import io.swagger.client.model.ValidationError
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class ProjectApi(
  val defBasePath: String = "https://hoopla.eu.looker.com:19999/api/3.0",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ProjectApiAsyncHelper(client, config)

  /**
   * Get All Git Branchs
   * ### Get All Git Branches  Returns a list of git branches in the project repository 
   *
   * @param projectId Project Id 
   * @return List[GitBranch]
   */
  def allGitBranches(projectId: String): Option[List[GitBranch]] = {
    val await = Try(Await.result(allGitBranchesAsync(projectId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Git Branchs asynchronously
   * ### Get All Git Branches  Returns a list of git branches in the project repository 
   *
   * @param projectId Project Id 
   * @return Future(List[GitBranch])
   */
  def allGitBranchesAsync(projectId: String): Future[List[GitBranch]] = {
      helper.allGitBranches(projectId)
  }

  /**
   * Get All Git Connection Tests
   * ### Get All Git Connection Tests  Returns a list of tests which can be run against a project&#39;s git connection 
   *
   * @param projectId Project Id 
   * @return List[GitConnectionTest]
   */
  def allGitConnectionTests(projectId: String): Option[List[GitConnectionTest]] = {
    val await = Try(Await.result(allGitConnectionTestsAsync(projectId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Git Connection Tests asynchronously
   * ### Get All Git Connection Tests  Returns a list of tests which can be run against a project&#39;s git connection 
   *
   * @param projectId Project Id 
   * @return Future(List[GitConnectionTest])
   */
  def allGitConnectionTestsAsync(projectId: String): Future[List[GitConnectionTest]] = {
      helper.allGitConnectionTests(projectId)
  }

  /**
   * Get All Project Files
   * ### Get All Project Files  Returns a list of the files in the project 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return List[ProjectFile]
   */
  def allProjectFiles(projectId: String, fields: Option[String] = None): Option[List[ProjectFile]] = {
    val await = Try(Await.result(allProjectFilesAsync(projectId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Project Files asynchronously
   * ### Get All Project Files  Returns a list of the files in the project 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return Future(List[ProjectFile])
   */
  def allProjectFilesAsync(projectId: String, fields: Option[String] = None): Future[List[ProjectFile]] = {
      helper.allProjectFiles(projectId, fields)
  }

  /**
   * Get All Projects
   * ### Get All Projects  Returns all projects visible to the current user 
   *
   * @param fields Requested fields (optional)
   * @return List[Project]
   */
  def allProjects(fields: Option[String] = None): Option[List[Project]] = {
    val await = Try(Await.result(allProjectsAsync(fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Projects asynchronously
   * ### Get All Projects  Returns all projects visible to the current user 
   *
   * @param fields Requested fields (optional)
   * @return Future(List[Project])
   */
  def allProjectsAsync(fields: Option[String] = None): Future[List[Project]] = {
      helper.allProjects(fields)
  }

  /**
   * Create Deploy Key
   * ### Create Git Deploy Key  Create a public/private key pair for authenticating ssh git requests from Looker to a remote git repository for a particular Looker project.  Returns the public key of the generated ssh key pair.  Copy this public key to your remote git repository&#39;s ssh keys configuration so that the remote git service can validate and accept git requests from the Looker server. 
   *
   * @param projectId Project Id 
   * @return String
   */
  def createGitDeployKey(projectId: String): Option[String] = {
    val await = Try(Await.result(createGitDeployKeyAsync(projectId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Deploy Key asynchronously
   * ### Create Git Deploy Key  Create a public/private key pair for authenticating ssh git requests from Looker to a remote git repository for a particular Looker project.  Returns the public key of the generated ssh key pair.  Copy this public key to your remote git repository&#39;s ssh keys configuration so that the remote git service can validate and accept git requests from the Looker server. 
   *
   * @param projectId Project Id 
   * @return Future(String)
   */
  def createGitDeployKeyAsync(projectId: String): Future[String] = {
      helper.createGitDeployKey(projectId)
  }

  /**
   * Create Project
   * ### Create A Project  dev mode required. - Call &#x60;update_session&#x60; to select the &#39;dev&#39; workspace.  &#x60;name&#x60; is required. &#x60;git_remote_url&#x60; is not allowed. To configure Git for the newly created project, follow the instructions in &#x60;update_project&#x60;.  
   *
   * @param body Project (optional)
   * @return Project
   */
  def createProject(body: Option[Project] = None): Option[Project] = {
    val await = Try(Await.result(createProjectAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Project asynchronously
   * ### Create A Project  dev mode required. - Call &#x60;update_session&#x60; to select the &#39;dev&#39; workspace.  &#x60;name&#x60; is required. &#x60;git_remote_url&#x60; is not allowed. To configure Git for the newly created project, follow the instructions in &#x60;update_project&#x60;.  
   *
   * @param body Project (optional)
   * @return Future(Project)
   */
  def createProjectAsync(body: Option[Project] = None): Future[Project] = {
      helper.createProject(body)
  }

  /**
   * Git Deploy Key
   * ### Git Deploy Key  Returns the ssh public key previously created for a project&#39;s git repository. 
   *
   * @param projectId Project Id 
   * @return String
   */
  def gitDeployKey(projectId: String): Option[String] = {
    val await = Try(Await.result(gitDeployKeyAsync(projectId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Git Deploy Key asynchronously
   * ### Git Deploy Key  Returns the ssh public key previously created for a project&#39;s git repository. 
   *
   * @param projectId Project Id 
   * @return Future(String)
   */
  def gitDeployKeyAsync(projectId: String): Future[String] = {
      helper.gitDeployKey(projectId)
  }

  /**
   * Get Project
   * ### Get A Project  Returns the project with the given project id 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return Project
   */
  def project(projectId: String, fields: Option[String] = None): Option[Project] = {
    val await = Try(Await.result(projectAsync(projectId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Project asynchronously
   * ### Get A Project  Returns the project with the given project id 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return Future(Project)
   */
  def projectAsync(projectId: String, fields: Option[String] = None): Future[Project] = {
      helper.project(projectId, fields)
  }

  /**
   * Get Project File
   * ### Get Project File Info  Returns information about a file in the project 
   *
   * @param projectId Project Id 
   * @param fileId File Id 
   * @param fields Requested fields (optional)
   * @return ProjectFile
   */
  def projectFile(projectId: String, fileId: String, fields: Option[String] = None): Option[ProjectFile] = {
    val await = Try(Await.result(projectFileAsync(projectId, fileId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Project File asynchronously
   * ### Get Project File Info  Returns information about a file in the project 
   *
   * @param projectId Project Id 
   * @param fileId File Id 
   * @param fields Requested fields (optional)
   * @return Future(ProjectFile)
   */
  def projectFileAsync(projectId: String, fileId: String, fields: Option[String] = None): Future[ProjectFile] = {
      helper.projectFile(projectId, fileId, fields)
  }

  /**
   * Cached Project Validation Results
   * ### Get Cached Project Validation Results  Returns the cached results of a previous project validation calculation, if any. Returns http status 204 No Content if no validation results exist.  Validating the content of all the files in a project can be computationally intensive for large projects. Use this API to simply fetch the results of the most recent project validation rather than revalidating the entire project from scratch.  A value of &#x60;\&quot;stale\&quot;: true&#x60; in the response indicates that the project has changed since the cached validation results were computed. The cached validation results may no longer reflect the current state of the project. 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return ProjectValidationCache
   */
  def projectValidationResults(projectId: String, fields: Option[String] = None): Option[ProjectValidationCache] = {
    val await = Try(Await.result(projectValidationResultsAsync(projectId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Cached Project Validation Results asynchronously
   * ### Get Cached Project Validation Results  Returns the cached results of a previous project validation calculation, if any. Returns http status 204 No Content if no validation results exist.  Validating the content of all the files in a project can be computationally intensive for large projects. Use this API to simply fetch the results of the most recent project validation rather than revalidating the entire project from scratch.  A value of &#x60;\&quot;stale\&quot;: true&#x60; in the response indicates that the project has changed since the cached validation results were computed. The cached validation results may no longer reflect the current state of the project. 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return Future(ProjectValidationCache)
   */
  def projectValidationResultsAsync(projectId: String, fields: Option[String] = None): Future[ProjectValidationCache] = {
      helper.projectValidationResults(projectId, fields)
  }

  /**
   * Get Project Workspace
   * ### Get Project Workspace  Returns information about the state of the project files in the currently selected workspace 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return ProjectWorkspace
   */
  def projectWorkspace(projectId: String, fields: Option[String] = None): Option[ProjectWorkspace] = {
    val await = Try(Await.result(projectWorkspaceAsync(projectId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Project Workspace asynchronously
   * ### Get Project Workspace  Returns information about the state of the project files in the currently selected workspace 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return Future(ProjectWorkspace)
   */
  def projectWorkspaceAsync(projectId: String, fields: Option[String] = None): Future[ProjectWorkspace] = {
      helper.projectWorkspace(projectId, fields)
  }

  /**
   * Reset To Production
   * ### Reset a project to the revision of the project that is in production.  **DANGER** this will delete any changes that have not been pushed to a remote repository. 
   *
   * @param projectId Id of project 
   * @return String
   */
  def resetProjectToProduction(projectId: String): Option[String] = {
    val await = Try(Await.result(resetProjectToProductionAsync(projectId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reset To Production asynchronously
   * ### Reset a project to the revision of the project that is in production.  **DANGER** this will delete any changes that have not been pushed to a remote repository. 
   *
   * @param projectId Id of project 
   * @return Future(String)
   */
  def resetProjectToProductionAsync(projectId: String): Future[String] = {
      helper.resetProjectToProduction(projectId)
  }

  /**
   * Reset To Remote
   * ### Reset a project development branch to the revision of the project that is on the remote.  **DANGER** this will delete any changes that have not been pushed to a remote repository. 
   *
   * @param projectId Id of project 
   * @return String
   */
  def resetProjectToRemote(projectId: String): Option[String] = {
    val await = Try(Await.result(resetProjectToRemoteAsync(projectId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Reset To Remote asynchronously
   * ### Reset a project development branch to the revision of the project that is on the remote.  **DANGER** this will delete any changes that have not been pushed to a remote repository. 
   *
   * @param projectId Id of project 
   * @return Future(String)
   */
  def resetProjectToRemoteAsync(projectId: String): Future[String] = {
      helper.resetProjectToRemote(projectId)
  }

  /**
   * Run Git Connection Test
   * ### Run a git connection test  Run the named test on the git service used by this project and return the result. This is intended to help debug git connections when things do not work properly, to give more helpful information about why a git url is not working with Looker. They are intended to be run in the order they are returned from the /projects/ID/git_connection_tests endpoint. 
   *
   * @param projectId Project Id 
   * @param testId Test Id 
   * @return GitConnectionTestResult
   */
  def runGitConnectionTest(projectId: String, testId: String): Option[GitConnectionTestResult] = {
    val await = Try(Await.result(runGitConnectionTestAsync(projectId, testId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Run Git Connection Test asynchronously
   * ### Run a git connection test  Run the named test on the git service used by this project and return the result. This is intended to help debug git connections when things do not work properly, to give more helpful information about why a git url is not working with Looker. They are intended to be run in the order they are returned from the /projects/ID/git_connection_tests endpoint. 
   *
   * @param projectId Project Id 
   * @param testId Test Id 
   * @return Future(GitConnectionTestResult)
   */
  def runGitConnectionTestAsync(projectId: String, testId: String): Future[GitConnectionTestResult] = {
      helper.runGitConnectionTest(projectId, testId)
  }

  /**
   * Update Project
   * ### Update Project Configuration  Apply changes to a project&#39;s configuration.   #### Configuring Git for a Project  To set up a Looker project with a remote git repository, follow these steps:  1. Call &#x60;update_session&#x60; to select the &#39;dev&#39; workspace. 1. Call &#x60;create_git_deploy_key&#x60; to create a new deploy key for the project 1. Copy the deploy key text into the remote git repository&#39;s ssh key configuration 1. Call &#x60;update_project&#x60; to set project&#39;s &#x60;git_remote_url&#x60; ()and &#x60;git_service_name&#x60;, if necessary).  When you modify a project&#39;s &#x60;git_remote_url&#x60;, Looker connects to the remote repository to fetch metadata. The remote git repository MUST be configured with the Looker-generated deploy key for this project prior to setting the project&#39;s &#x60;git_remote_url&#x60;.  To set up a Looker project with a git repository residing on the Looker server (a &#39;bare&#39; git repo): 1. Call &#x60;update_session&#x60; to select the &#39;dev&#39; workspace. 1. Call &#x60;update_project&#x60; setting &#x60;git_remote_url&#x60; to nil and &#x60;git_service_name&#x60; to \&quot;bare\&quot;.  
   *
   * @param projectId Project Id 
   * @param body Project 
   * @param fields Requested fields (optional)
   * @return Project
   */
  def updateProject(projectId: String, body: Project, fields: Option[String] = None): Option[Project] = {
    val await = Try(Await.result(updateProjectAsync(projectId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Project asynchronously
   * ### Update Project Configuration  Apply changes to a project&#39;s configuration.   #### Configuring Git for a Project  To set up a Looker project with a remote git repository, follow these steps:  1. Call &#x60;update_session&#x60; to select the &#39;dev&#39; workspace. 1. Call &#x60;create_git_deploy_key&#x60; to create a new deploy key for the project 1. Copy the deploy key text into the remote git repository&#39;s ssh key configuration 1. Call &#x60;update_project&#x60; to set project&#39;s &#x60;git_remote_url&#x60; ()and &#x60;git_service_name&#x60;, if necessary).  When you modify a project&#39;s &#x60;git_remote_url&#x60;, Looker connects to the remote repository to fetch metadata. The remote git repository MUST be configured with the Looker-generated deploy key for this project prior to setting the project&#39;s &#x60;git_remote_url&#x60;.  To set up a Looker project with a git repository residing on the Looker server (a &#39;bare&#39; git repo): 1. Call &#x60;update_session&#x60; to select the &#39;dev&#39; workspace. 1. Call &#x60;update_project&#x60; setting &#x60;git_remote_url&#x60; to nil and &#x60;git_service_name&#x60; to \&quot;bare\&quot;.  
   *
   * @param projectId Project Id 
   * @param body Project 
   * @param fields Requested fields (optional)
   * @return Future(Project)
   */
  def updateProjectAsync(projectId: String, body: Project, fields: Option[String] = None): Future[Project] = {
      helper.updateProject(projectId, body, fields)
  }

  /**
   * Validate Project
   * ### Validate Project  Performs lint validation of all lookml files in the project. Returns a list of errors found, if any.  Validating the content of all the files in a project can be computationally intensive for large projects. For best performance, call &#x60;validate_project(project_id)&#x60; only when you really want to recompute project validation. To quickly display the results of the most recent project validation (without recomputing), use &#x60;project_validation_results(project_id)&#x60; 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return ProjectValidation
   */
  def validateProject(projectId: String, fields: Option[String] = None): Option[ProjectValidation] = {
    val await = Try(Await.result(validateProjectAsync(projectId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Validate Project asynchronously
   * ### Validate Project  Performs lint validation of all lookml files in the project. Returns a list of errors found, if any.  Validating the content of all the files in a project can be computationally intensive for large projects. For best performance, call &#x60;validate_project(project_id)&#x60; only when you really want to recompute project validation. To quickly display the results of the most recent project validation (without recomputing), use &#x60;project_validation_results(project_id)&#x60; 
   *
   * @param projectId Project Id 
   * @param fields Requested fields (optional)
   * @return Future(ProjectValidation)
   */
  def validateProjectAsync(projectId: String, fields: Option[String] = None): Future[ProjectValidation] = {
      helper.validateProject(projectId, fields)
  }

}

class ProjectApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def allGitBranches(projectId: String)(implicit reader: ClientResponseReader[List[GitBranch]]): Future[List[GitBranch]] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/git_branches")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->allGitBranches")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allGitConnectionTests(projectId: String)(implicit reader: ClientResponseReader[List[GitConnectionTest]]): Future[List[GitConnectionTest]] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/git_connection_tests")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->allGitConnectionTests")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allProjectFiles(projectId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[ProjectFile]]): Future[List[ProjectFile]] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/files")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->allProjectFiles")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allProjects(fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Project]]): Future[List[Project]] = {
    // create path and map variables
    val path = (addFmt("/projects"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createGitDeployKey(projectId: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/git/deploy_key")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->createGitDeployKey")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createProject(body: Option[Project] = None
    )(implicit reader: ClientResponseReader[Project], writer: RequestWriter[Option[Project]]): Future[Project] = {
    // create path and map variables
    val path = (addFmt("/projects"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def gitDeployKey(projectId: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/git/deploy_key")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->gitDeployKey")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def project(projectId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[Project]): Future[Project] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->project")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def projectFile(projectId: String,
    fileId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[ProjectFile]): Future[ProjectFile] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/files/file")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->projectFile")

    if (fileId == null) throw new Exception("Missing required parameter 'fileId' when calling ProjectApi->projectFile")

    queryParams += "file_id" -> fileId.toString
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def projectValidationResults(projectId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[ProjectValidationCache]): Future[ProjectValidationCache] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/validate")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->projectValidationResults")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def projectWorkspace(projectId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[ProjectWorkspace]): Future[ProjectWorkspace] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/current_workspace")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->projectWorkspace")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def resetProjectToProduction(projectId: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/reset_to_production")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->resetProjectToProduction")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def resetProjectToRemote(projectId: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/reset_to_remote")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->resetProjectToRemote")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def runGitConnectionTest(projectId: String,
    testId: String)(implicit reader: ClientResponseReader[GitConnectionTestResult]): Future[GitConnectionTestResult] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/git_connection_tests/{test_id}")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString)
      replaceAll("\\{" + "test_id" + "\\}", testId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->runGitConnectionTest")

    if (testId == null) throw new Exception("Missing required parameter 'testId' when calling ProjectApi->runGitConnectionTest")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateProject(projectId: String,
    body: Project,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[Project], writer: RequestWriter[Project]): Future[Project] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->updateProject")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling ProjectApi->updateProject")
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def validateProject(projectId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[ProjectValidation]): Future[ProjectValidation] = {
    // create path and map variables
    val path = (addFmt("/projects/{project_id}/validate")
      replaceAll("\\{" + "project_id" + "\\}", projectId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectId == null) throw new Exception("Missing required parameter 'projectId' when calling ProjectApi->validateProject")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
