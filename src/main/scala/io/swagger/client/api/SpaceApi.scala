/**
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.Dashboard
import io.swagger.client.model.Error
import io.swagger.client.model.LookWithQuery
import io.swagger.client.model.Space
import io.swagger.client.model.SpaceBase
import io.swagger.client.model.ValidationError
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class SpaceApi(
  val defBasePath: String = "https://hoopla.eu.looker.com:19999/api/3.0",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new SpaceApiAsyncHelper(client, config)

  /**
   * Get All Spaces
   * ### Get information about all spaces.
   *
   * @param fields Requested fields. (optional)
   * @return List[SpaceBase]
   */
  def allSpaces(fields: Option[String] = None): Option[List[SpaceBase]] = {
    val await = Try(Await.result(allSpacesAsync(fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Spaces asynchronously
   * ### Get information about all spaces.
   *
   * @param fields Requested fields. (optional)
   * @return Future(List[SpaceBase])
   */
  def allSpacesAsync(fields: Option[String] = None): Future[List[SpaceBase]] = {
      helper.allSpaces(fields)
  }

  /**
   * Create Space
   * ### Create a space with specified information.  Caller must have permission to edit the parent space and to create spaces, otherwise the request returns 404 Not Found. 
   *
   * @param body Space (optional)
   * @return Space
   */
  def createSpace(body: Option[Space] = None): Option[Space] = {
    val await = Try(Await.result(createSpaceAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Space asynchronously
   * ### Create a space with specified information.  Caller must have permission to edit the parent space and to create spaces, otherwise the request returns 404 Not Found. 
   *
   * @param body Space (optional)
   * @return Future(Space)
   */
  def createSpaceAsync(body: Option[Space] = None): Future[Space] = {
      helper.createSpace(body)
  }

  /**
   * Delete Space
   * ### Delete the space with a specific id including any children spaces. **DANGER** this will delete all looks and dashboards in the space. 
   *
   * @param spaceId Id of space 
   * @return String
   */
  def deleteSpace(spaceId: String): Option[String] = {
    val await = Try(Await.result(deleteSpaceAsync(spaceId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Space asynchronously
   * ### Delete the space with a specific id including any children spaces. **DANGER** this will delete all looks and dashboards in the space. 
   *
   * @param spaceId Id of space 
   * @return Future(String)
   */
  def deleteSpaceAsync(spaceId: String): Future[String] = {
      helper.deleteSpace(spaceId)
  }

  /**
   * Search Spaces
   * Search for spaces by creator id, parent id, name, etc
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param limit Number of results to return. (used with offset and takes priority over page and per_page) (optional)
   * @param offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page) (optional)
   * @param sorts Fields to sort by. (optional)
   * @param name Match Space title. (optional)
   * @param id Match Space id (optional)
   * @param parentId Filter on a children of a particular space. (optional)
   * @param creatorId Filter on dashboards created by a particular user. (optional)
   * @return List[Space]
   */
  def searchSpaces(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, limit: Option[Long] = None, offset: Option[Long] = None, sorts: Option[String] = None, name: Option[String] = None, id: Option[Long] = None, parentId: Option[String] = None, creatorId: Option[String] = None): Option[List[Space]] = {
    val await = Try(Await.result(searchSpacesAsync(fields, page, perPage, limit, offset, sorts, name, id, parentId, creatorId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Search Spaces asynchronously
   * Search for spaces by creator id, parent id, name, etc
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param limit Number of results to return. (used with offset and takes priority over page and per_page) (optional)
   * @param offset Number of results to skip before returning any. (used with limit and takes priority over page and per_page) (optional)
   * @param sorts Fields to sort by. (optional)
   * @param name Match Space title. (optional)
   * @param id Match Space id (optional)
   * @param parentId Filter on a children of a particular space. (optional)
   * @param creatorId Filter on dashboards created by a particular user. (optional)
   * @return Future(List[Space])
   */
  def searchSpacesAsync(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, limit: Option[Long] = None, offset: Option[Long] = None, sorts: Option[String] = None, name: Option[String] = None, id: Option[Long] = None, parentId: Option[String] = None, creatorId: Option[String] = None): Future[List[Space]] = {
      helper.searchSpaces(fields, page, perPage, limit, offset, sorts, name, id, parentId, creatorId)
  }

  /**
   * Get Space
   * ### Get information about the space with a specific id.
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Space
   */
  def space(spaceId: String, fields: Option[String] = None): Option[Space] = {
    val await = Try(Await.result(spaceAsync(spaceId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Space asynchronously
   * ### Get information about the space with a specific id.
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Future(Space)
   */
  def spaceAsync(spaceId: String, fields: Option[String] = None): Future[Space] = {
      helper.space(spaceId, fields)
  }

  /**
   * Get Space Ancestors
   * ### Get the ancestors of a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return List[Space]
   */
  def spaceAncestors(spaceId: String, fields: Option[String] = None): Option[List[Space]] = {
    val await = Try(Await.result(spaceAncestorsAsync(spaceId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Space Ancestors asynchronously
   * ### Get the ancestors of a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Future(List[Space])
   */
  def spaceAncestorsAsync(spaceId: String, fields: Option[String] = None): Future[List[Space]] = {
      helper.spaceAncestors(spaceId, fields)
  }

  /**
   * Get Space Children
   * ### Get the children of a space.
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @return List[Space]
   */
  def spaceChildren(spaceId: String, fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None): Option[List[Space]] = {
    val await = Try(Await.result(spaceChildrenAsync(spaceId, fields, page, perPage, sorts), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Space Children asynchronously
   * ### Get the children of a space.
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @return Future(List[Space])
   */
  def spaceChildrenAsync(spaceId: String, fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None): Future[List[Space]] = {
      helper.spaceChildren(spaceId, fields, page, perPage, sorts)
  }

  /**
   * Search Space Children
   * ### Search the children of a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param name Match Space name. (optional)
   * @return List[Space]
   */
  def spaceChildrenSearch(spaceId: String, fields: Option[String] = None, sorts: Option[String] = None, name: Option[String] = None): Option[List[Space]] = {
    val await = Try(Await.result(spaceChildrenSearchAsync(spaceId, fields, sorts, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Search Space Children asynchronously
   * ### Search the children of a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param name Match Space name. (optional)
   * @return Future(List[Space])
   */
  def spaceChildrenSearchAsync(spaceId: String, fields: Option[String] = None, sorts: Option[String] = None, name: Option[String] = None): Future[List[Space]] = {
      helper.spaceChildrenSearch(spaceId, fields, sorts, name)
  }

  /**
   * Get Space Dashboards
   * ### Get the dashboards in a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return List[Dashboard]
   */
  def spaceDashboards(spaceId: String, fields: Option[String] = None): Option[List[Dashboard]] = {
    val await = Try(Await.result(spaceDashboardsAsync(spaceId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Space Dashboards asynchronously
   * ### Get the dashboards in a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Future(List[Dashboard])
   */
  def spaceDashboardsAsync(spaceId: String, fields: Option[String] = None): Future[List[Dashboard]] = {
      helper.spaceDashboards(spaceId, fields)
  }

  /**
   * Get Space Looks
   * ### Get the looks in a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return List[LookWithQuery]
   */
  def spaceLooks(spaceId: String, fields: Option[String] = None): Option[List[LookWithQuery]] = {
    val await = Try(Await.result(spaceLooksAsync(spaceId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Space Looks asynchronously
   * ### Get the looks in a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Future(List[LookWithQuery])
   */
  def spaceLooksAsync(spaceId: String, fields: Option[String] = None): Future[List[LookWithQuery]] = {
      helper.spaceLooks(spaceId, fields)
  }

  /**
   * Get Space Parent
   * ### Get the parent of a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Space
   */
  def spaceParent(spaceId: String, fields: Option[String] = None): Option[Space] = {
    val await = Try(Await.result(spaceParentAsync(spaceId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Space Parent asynchronously
   * ### Get the parent of a space
   *
   * @param spaceId Id of space 
   * @param fields Requested fields. (optional)
   * @return Future(Space)
   */
  def spaceParentAsync(spaceId: String, fields: Option[String] = None): Future[Space] = {
      helper.spaceParent(spaceId, fields)
  }

  /**
   * Update Space
   * ### Update the space with a specific id.
   *
   * @param spaceId Id of space 
   * @param body Space 
   * @return Space
   */
  def updateSpace(spaceId: String, body: Space): Option[Space] = {
    val await = Try(Await.result(updateSpaceAsync(spaceId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Space asynchronously
   * ### Update the space with a specific id.
   *
   * @param spaceId Id of space 
   * @param body Space 
   * @return Future(Space)
   */
  def updateSpaceAsync(spaceId: String, body: Space): Future[Space] = {
      helper.updateSpace(spaceId, body)
  }

}

class SpaceApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def allSpaces(fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[SpaceBase]]): Future[List[SpaceBase]] = {
    // create path and map variables
    val path = (addFmt("/spaces"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createSpace(body: Option[Space] = None
    )(implicit reader: ClientResponseReader[Space], writer: RequestWriter[Option[Space]]): Future[Space] = {
    // create path and map variables
    val path = (addFmt("/spaces"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteSpace(spaceId: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->deleteSpace")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def searchSpaces(fields: Option[String] = None,
    page: Option[Long] = None,
    perPage: Option[Long] = None,
    limit: Option[Long] = None,
    offset: Option[Long] = None,
    sorts: Option[String] = None,
    name: Option[String] = None,
    id: Option[Long] = None,
    parentId: Option[String] = None,
    creatorId: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Space]]): Future[List[Space]] = {
    // create path and map variables
    val path = (addFmt("/spaces/search"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    perPage match {
      case Some(param) => queryParams += "per_page" -> param.toString
      case _ => queryParams
    }
    limit match {
      case Some(param) => queryParams += "limit" -> param.toString
      case _ => queryParams
    }
    offset match {
      case Some(param) => queryParams += "offset" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    id match {
      case Some(param) => queryParams += "id" -> param.toString
      case _ => queryParams
    }
    parentId match {
      case Some(param) => queryParams += "parent_id" -> param.toString
      case _ => queryParams
    }
    creatorId match {
      case Some(param) => queryParams += "creator_id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def space(spaceId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[Space]): Future[Space] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->space")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def spaceAncestors(spaceId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Space]]): Future[List[Space]] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}/ancestors")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->spaceAncestors")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def spaceChildren(spaceId: String,
    fields: Option[String] = None,
    page: Option[Long] = None,
    perPage: Option[Long] = None,
    sorts: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Space]]): Future[List[Space]] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}/children")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->spaceChildren")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    perPage match {
      case Some(param) => queryParams += "per_page" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def spaceChildrenSearch(spaceId: String,
    fields: Option[String] = None,
    sorts: Option[String] = None,
    name: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Space]]): Future[List[Space]] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}/children/search")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->spaceChildrenSearch")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def spaceDashboards(spaceId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Dashboard]]): Future[List[Dashboard]] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}/dashboards")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->spaceDashboards")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def spaceLooks(spaceId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[LookWithQuery]]): Future[List[LookWithQuery]] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}/looks")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->spaceLooks")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def spaceParent(spaceId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[Space]): Future[Space] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}/parent")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->spaceParent")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateSpace(spaceId: String,
    body: Space)(implicit reader: ClientResponseReader[Space], writer: RequestWriter[Space]): Future[Space] = {
    // create path and map variables
    val path = (addFmt("/spaces/{space_id}")
      replaceAll("\\{" + "space_id" + "\\}", spaceId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (spaceId == null) throw new Exception("Missing required parameter 'spaceId' when calling SpaceApi->updateSpace")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling SpaceApi->updateSpace")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
