/**
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import java.text.SimpleDateFormat

import io.swagger.client.model.AccessFilter
import io.swagger.client.model.CredentialsApi
import io.swagger.client.model.CredentialsApi3
import io.swagger.client.model.CredentialsEmail
import io.swagger.client.model.CredentialsEmbed
import io.swagger.client.model.CredentialsGoogle
import io.swagger.client.model.CredentialsLDAP
import io.swagger.client.model.CredentialsLookerOpenid
import io.swagger.client.model.CredentialsOIDC
import io.swagger.client.model.CredentialsSaml
import io.swagger.client.model.CredentialsTotp
import io.swagger.client.model.Error
import io.swagger.client.model.Role
import io.swagger.client.model.Session
import io.swagger.client.model.User
import io.swagger.client.model.UserAttributeWithValue
import io.swagger.client.model.ValidationError
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class UserApi(
  val defBasePath: String = "https://hoopla.eu.looker.com:19999/api/3.0",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new UserApiAsyncHelper(client, config)

  /**
   * Get All Access Filters
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return List[AccessFilter]
   */
  def allUserAccessFilters(userId: Long, fields: Option[String] = None): Option[List[AccessFilter]] = {
    val await = Try(Await.result(allUserAccessFiltersAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Access Filters asynchronously
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(List[AccessFilter])
   */
  def allUserAccessFiltersAsync(userId: Long, fields: Option[String] = None): Future[List[AccessFilter]] = {
      helper.allUserAccessFilters(userId, fields)
  }

  /**
   * Get All API 3 Credentials
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return List[CredentialsApi3]
   */
  def allUserCredentialsApi3s(userId: Long, fields: Option[String] = None): Option[List[CredentialsApi3]] = {
    val await = Try(Await.result(allUserCredentialsApi3sAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All API 3 Credentials asynchronously
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(List[CredentialsApi3])
   */
  def allUserCredentialsApi3sAsync(userId: Long, fields: Option[String] = None): Future[List[CredentialsApi3]] = {
      helper.allUserCredentialsApi3s(userId, fields)
  }

  /**
   * Get All Embedding Credentials
   * ### Embed login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return List[CredentialsEmbed]
   */
  def allUserCredentialsEmbeds(userId: Long, fields: Option[String] = None): Option[List[CredentialsEmbed]] = {
    val await = Try(Await.result(allUserCredentialsEmbedsAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Embedding Credentials asynchronously
   * ### Embed login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(List[CredentialsEmbed])
   */
  def allUserCredentialsEmbedsAsync(userId: Long, fields: Option[String] = None): Future[List[CredentialsEmbed]] = {
      helper.allUserCredentialsEmbeds(userId, fields)
  }

  /**
   * Get All Web Login Sessions
   * ### Web login session for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return List[Session]
   */
  def allUserSessions(userId: Long, fields: Option[String] = None): Option[List[Session]] = {
    val await = Try(Await.result(allUserSessionsAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Web Login Sessions asynchronously
   * ### Web login session for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(List[Session])
   */
  def allUserSessionsAsync(userId: Long, fields: Option[String] = None): Future[List[Session]] = {
      helper.allUserSessions(userId, fields)
  }

  /**
   * Get All Users
   * ### Get information about all users. 
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param ids Optional list of ids to get specific users. (optional)
   * @return List[User]
   */
  def allUsers(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None, ids: Option[List[Long]] = None): Option[List[User]] = {
    val await = Try(Await.result(allUsersAsync(fields, page, perPage, sorts, ids), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get All Users asynchronously
   * ### Get information about all users. 
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param ids Optional list of ids to get specific users. (optional)
   * @return Future(List[User])
   */
  def allUsersAsync(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None, ids: Option[List[Long]] = None): Future[List[User]] = {
      helper.allUsers(fields, page, perPage, sorts, ids)
  }

  /**
   * Create User
   * ### Create a user with the specified information. 
   *
   * @param body User (optional)
   * @param fields Requested fields. (optional)
   * @return User
   */
  def createUser(body: Option[User] = None, fields: Option[String] = None): Option[User] = {
    val await = Try(Await.result(createUserAsync(body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create User asynchronously
   * ### Create a user with the specified information. 
   *
   * @param body User (optional)
   * @param fields Requested fields. (optional)
   * @return Future(User)
   */
  def createUserAsync(body: Option[User] = None, fields: Option[String] = None): Future[User] = {
      helper.createUser(body, fields)
  }

  /**
   * Create Access Filter
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param body Access Filter (optional)
   * @param fields Requested fields. (optional)
   * @return AccessFilter
   */
  def createUserAccessFilter(userId: Long, body: Option[AccessFilter] = None, fields: Option[String] = None): Option[AccessFilter] = {
    val await = Try(Await.result(createUserAccessFilterAsync(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Access Filter asynchronously
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param body Access Filter (optional)
   * @param fields Requested fields. (optional)
   * @return Future(AccessFilter)
   */
  def createUserAccessFilterAsync(userId: Long, body: Option[AccessFilter] = None, fields: Option[String] = None): Future[AccessFilter] = {
      helper.createUserAccessFilter(userId, body, fields)
  }

  /**
   * Create API Credential
   * ### Create API Credential. SUPPORT FOR THIS HAS BEEN REMOVED. 
   *
   * @param userId Id of user 
   * @param body API Credential (optional)
   * @return CredentialsApi
   */
  def createUserCredentialsApi(userId: Long, body: Option[CredentialsApi] = None): Option[CredentialsApi] = {
    val await = Try(Await.result(createUserCredentialsApiAsync(userId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create API Credential asynchronously
   * ### Create API Credential. SUPPORT FOR THIS HAS BEEN REMOVED. 
   *
   * @param userId Id of user 
   * @param body API Credential (optional)
   * @return Future(CredentialsApi)
   */
  def createUserCredentialsApiAsync(userId: Long, body: Option[CredentialsApi] = None): Future[CredentialsApi] = {
      helper.createUserCredentialsApi(userId, body)
  }

  /**
   * Create API 3 Credential
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId id of user 
   * @param body API 3 Credential (optional)
   * @param fields Requested fields. (optional)
   * @return CredentialsApi3
   */
  def createUserCredentialsApi3(userId: Long, body: Option[CredentialsApi3] = None, fields: Option[String] = None): Option[CredentialsApi3] = {
    val await = Try(Await.result(createUserCredentialsApi3Async(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create API 3 Credential asynchronously
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId id of user 
   * @param body API 3 Credential (optional)
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsApi3)
   */
  def createUserCredentialsApi3Async(userId: Long, body: Option[CredentialsApi3] = None, fields: Option[String] = None): Future[CredentialsApi3] = {
      helper.createUserCredentialsApi3(userId, body, fields)
  }

  /**
   * Create Email/Password Credential
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @param body Email/Password Credential (optional)
   * @param fields Requested fields. (optional)
   * @return CredentialsEmail
   */
  def createUserCredentialsEmail(userId: Long, body: Option[CredentialsEmail] = None, fields: Option[String] = None): Option[CredentialsEmail] = {
    val await = Try(Await.result(createUserCredentialsEmailAsync(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Email/Password Credential asynchronously
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @param body Email/Password Credential (optional)
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsEmail)
   */
  def createUserCredentialsEmailAsync(userId: Long, body: Option[CredentialsEmail] = None, fields: Option[String] = None): Future[CredentialsEmail] = {
      helper.createUserCredentialsEmail(userId, body, fields)
  }

  /**
   * Create Password Reset Token
   * ### Create a password reset token. This will create a cryptographically secure random password reset token for the user. If the user already has a password reset token then this invalidates the old token and creates a new one. The token is expressed as the &#39;password_reset_url&#39; of the user&#39;s email/password credential object. This takes an optional &#39;expires&#39; param to indicate if the new token should be an expiring token. Tokens that expire are typically used for self-service password resets for existing users. Invitation emails for new users typically are not set to expire. The expire period is always 60 minutes when expires is enabled. This method can be called with an empty body. 
   *
   * @param userId Id of user 
   * @param expires Expiring token. (optional)
   * @param fields Requested fields. (optional)
   * @return CredentialsEmail
   */
  def createUserCredentialsEmailPasswordReset(userId: Long, expires: Option[Boolean] = None, fields: Option[String] = None): Option[CredentialsEmail] = {
    val await = Try(Await.result(createUserCredentialsEmailPasswordResetAsync(userId, expires, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Password Reset Token asynchronously
   * ### Create a password reset token. This will create a cryptographically secure random password reset token for the user. If the user already has a password reset token then this invalidates the old token and creates a new one. The token is expressed as the &#39;password_reset_url&#39; of the user&#39;s email/password credential object. This takes an optional &#39;expires&#39; param to indicate if the new token should be an expiring token. Tokens that expire are typically used for self-service password resets for existing users. Invitation emails for new users typically are not set to expire. The expire period is always 60 minutes when expires is enabled. This method can be called with an empty body. 
   *
   * @param userId Id of user 
   * @param expires Expiring token. (optional)
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsEmail)
   */
  def createUserCredentialsEmailPasswordResetAsync(userId: Long, expires: Option[Boolean] = None, fields: Option[String] = None): Future[CredentialsEmail] = {
      helper.createUserCredentialsEmailPasswordReset(userId, expires, fields)
  }

  /**
   * Create Two-Factor Credential
   * ### Two-factor login information for the specified user.
   *
   * @param userId id of user 
   * @param body Two-Factor Credential (optional)
   * @param fields Requested fields. (optional)
   * @return CredentialsTotp
   */
  def createUserCredentialsTotp(userId: Long, body: Option[CredentialsTotp] = None, fields: Option[String] = None): Option[CredentialsTotp] = {
    val await = Try(Await.result(createUserCredentialsTotpAsync(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create Two-Factor Credential asynchronously
   * ### Two-factor login information for the specified user.
   *
   * @param userId id of user 
   * @param body Two-Factor Credential (optional)
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsTotp)
   */
  def createUserCredentialsTotpAsync(userId: Long, body: Option[CredentialsTotp] = None, fields: Option[String] = None): Future[CredentialsTotp] = {
      helper.createUserCredentialsTotp(userId, body, fields)
  }

  /**
   * Delete User
   * ### Delete the user with a specific id.  **DANGER** this will delete the user and all looks and other information owned by the user. 
   *
   * @param userId Id of user 
   * @return String
   */
  def deleteUser(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete User asynchronously
   * ### Delete the user with a specific id.  **DANGER** this will delete the user and all looks and other information owned by the user. 
   *
   * @param userId Id of user 
   * @return Future(String)
   */
  def deleteUserAsync(userId: Long): Future[String] = {
      helper.deleteUser(userId)
  }

  /**
   * Delete Access Filter
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param accessFilterId id of Access Filter 
   * @return String
   */
  def deleteUserAccessFilter(userId: Long, accessFilterId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserAccessFilterAsync(userId, accessFilterId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Access Filter asynchronously
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param accessFilterId id of Access Filter 
   * @return Future(String)
   */
  def deleteUserAccessFilterAsync(userId: Long, accessFilterId: Long): Future[String] = {
      helper.deleteUserAccessFilter(userId, accessFilterId)
  }

  /**
   * Delete User Attribute User Value
   * ### Delete a user attribute value from a user&#39;s account settings.  After the user attribute value is deleted from the user&#39;s account settings, subsequent requests for the user attribute value for this user will draw from the user&#39;s groups or the default value of the user attribute. See [Get User Attribute Values](#!/User/user_attribute_user_values) for more information about how user attribute values are resolved. 
   *
   * @param userId Id of user 
   * @param userAttributeId Id of user attribute 
   * @return void
   */
  def deleteUserAttributeUserValue(userId: Long, userAttributeId: Long) = {
    val await = Try(Await.result(deleteUserAttributeUserValueAsync(userId, userAttributeId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete User Attribute User Value asynchronously
   * ### Delete a user attribute value from a user&#39;s account settings.  After the user attribute value is deleted from the user&#39;s account settings, subsequent requests for the user attribute value for this user will draw from the user&#39;s groups or the default value of the user attribute. See [Get User Attribute Values](#!/User/user_attribute_user_values) for more information about how user attribute values are resolved. 
   *
   * @param userId Id of user 
   * @param userAttributeId Id of user attribute 
   * @return Future(void)
   */
  def deleteUserAttributeUserValueAsync(userId: Long, userAttributeId: Long) = {
      helper.deleteUserAttributeUserValue(userId, userAttributeId)
  }

  /**
   * Delete API Credential
   * ### API login information for the specified user. This is for &#39;API Users&#39; used for the &#39;old&#39; query API. THIS SUPPORT HAS BEEN REMOVED.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsApi(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsApiAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete API Credential asynchronously
   * ### API login information for the specified user. This is for &#39;API Users&#39; used for the &#39;old&#39; query API. THIS SUPPORT HAS BEEN REMOVED.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsApiAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsApi(userId)
  }

  /**
   * Delete API 3 Credential
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId id of user 
   * @param credentialsApi3Id id of API 3 Credential 
   * @return String
   */
  def deleteUserCredentialsApi3(userId: Long, credentialsApi3Id: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsApi3Async(userId, credentialsApi3Id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete API 3 Credential asynchronously
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId id of user 
   * @param credentialsApi3Id id of API 3 Credential 
   * @return Future(String)
   */
  def deleteUserCredentialsApi3Async(userId: Long, credentialsApi3Id: Long): Future[String] = {
      helper.deleteUserCredentialsApi3(userId, credentialsApi3Id)
  }

  /**
   * Delete Email/Password Credential
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsEmail(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsEmailAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Email/Password Credential asynchronously
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsEmailAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsEmail(userId)
  }

  /**
   * Delete Embedding Credential
   * ### Embed login information for the specified user.
   *
   * @param userId id of user 
   * @param credentialsEmbedId id of Embedding Credential 
   * @return String
   */
  def deleteUserCredentialsEmbed(userId: Long, credentialsEmbedId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsEmbedAsync(userId, credentialsEmbedId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Embedding Credential asynchronously
   * ### Embed login information for the specified user.
   *
   * @param userId id of user 
   * @param credentialsEmbedId id of Embedding Credential 
   * @return Future(String)
   */
  def deleteUserCredentialsEmbedAsync(userId: Long, credentialsEmbedId: Long): Future[String] = {
      helper.deleteUserCredentialsEmbed(userId, credentialsEmbedId)
  }

  /**
   * Delete Google Auth Credential
   * ### Google authentication login information for the specified user.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsGoogle(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsGoogleAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Google Auth Credential asynchronously
   * ### Google authentication login information for the specified user.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsGoogleAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsGoogle(userId)
  }

  /**
   * Delete LDAP Credential
   * ### LDAP login information for the specified user.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsLdap(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsLdapAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete LDAP Credential asynchronously
   * ### LDAP login information for the specified user.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsLdapAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsLdap(userId)
  }

  /**
   * Delete Looker OpenId Credential
   * ### Looker Openid login information for the specified user. Used by Looker Analysts.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsLookerOpenid(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsLookerOpenidAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Looker OpenId Credential asynchronously
   * ### Looker Openid login information for the specified user. Used by Looker Analysts.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsLookerOpenidAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsLookerOpenid(userId)
  }

  /**
   * Delete OIDC Auth Credential
   * ### OpenID Connect (OIDC) authentication login information for the specified user.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsOidc(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsOidcAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete OIDC Auth Credential asynchronously
   * ### OpenID Connect (OIDC) authentication login information for the specified user.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsOidcAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsOidc(userId)
  }

  /**
   * Delete Saml Auth Credential
   * ### Saml authentication login information for the specified user.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsSaml(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsSamlAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Saml Auth Credential asynchronously
   * ### Saml authentication login information for the specified user.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsSamlAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsSaml(userId)
  }

  /**
   * Delete Two-Factor Credential
   * ### Two-factor login information for the specified user.
   *
   * @param userId id of user 
   * @return String
   */
  def deleteUserCredentialsTotp(userId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserCredentialsTotpAsync(userId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Two-Factor Credential asynchronously
   * ### Two-factor login information for the specified user.
   *
   * @param userId id of user 
   * @return Future(String)
   */
  def deleteUserCredentialsTotpAsync(userId: Long): Future[String] = {
      helper.deleteUserCredentialsTotp(userId)
  }

  /**
   * Delete Web Login Session
   * ### Web login session for the specified user.
   *
   * @param userId id of user 
   * @param sessionId id of Web Login Session 
   * @return String
   */
  def deleteUserSession(userId: Long, sessionId: Long): Option[String] = {
    val await = Try(Await.result(deleteUserSessionAsync(userId, sessionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete Web Login Session asynchronously
   * ### Web login session for the specified user.
   *
   * @param userId id of user 
   * @param sessionId id of Web Login Session 
   * @return Future(String)
   */
  def deleteUserSessionAsync(userId: Long, sessionId: Long): Future[String] = {
      helper.deleteUserSession(userId, sessionId)
  }

  /**
   * Get Current User
   * ### Get information about the current user; i.e. the user account currently calling the API. 
   *
   * @param fields Requested fields. (optional)
   * @return User
   */
  def me(fields: Option[String] = None): Option[User] = {
    val await = Try(Await.result(meAsync(fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Current User asynchronously
   * ### Get information about the current user; i.e. the user account currently calling the API. 
   *
   * @param fields Requested fields. (optional)
   * @return Future(User)
   */
  def meAsync(fields: Option[String] = None): Future[User] = {
      helper.me(fields)
  }

  /**
   * Search Users
   * ### Search users. 
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param id Match User Id. (optional)
   * @param firstName Match First name. (optional)
   * @param lastName Match Last name. (optional)
   * @param verifiedLookerEmployee Match Verified Looker employee. (optional)
   * @param email Match Email Address. (optional)
   * @param isDisabled Match Is disabled. (optional)
   * @param filterOr Do an OR search with parameters (optional)
   * @param contentMetadataId Id of content metadata to which users must have access (optional)
   * @param groupId Id of group of which users must be directly members (optional)
   * @return List[User]
   */
  def searchUsers(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None, id: Option[Long] = None, firstName: Option[String] = None, lastName: Option[String] = None, verifiedLookerEmployee: Option[Boolean] = None, email: Option[String] = None, isDisabled: Option[Boolean] = None, filterOr: Option[Boolean] = None, contentMetadataId: Option[Long] = None, groupId: Option[Long] = None): Option[List[User]] = {
    val await = Try(Await.result(searchUsersAsync(fields, page, perPage, sorts, id, firstName, lastName, verifiedLookerEmployee, email, isDisabled, filterOr, contentMetadataId, groupId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Search Users asynchronously
   * ### Search users. 
   *
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param id Match User Id. (optional)
   * @param firstName Match First name. (optional)
   * @param lastName Match Last name. (optional)
   * @param verifiedLookerEmployee Match Verified Looker employee. (optional)
   * @param email Match Email Address. (optional)
   * @param isDisabled Match Is disabled. (optional)
   * @param filterOr Do an OR search with parameters (optional)
   * @param contentMetadataId Id of content metadata to which users must have access (optional)
   * @param groupId Id of group of which users must be directly members (optional)
   * @return Future(List[User])
   */
  def searchUsersAsync(fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None, id: Option[Long] = None, firstName: Option[String] = None, lastName: Option[String] = None, verifiedLookerEmployee: Option[Boolean] = None, email: Option[String] = None, isDisabled: Option[Boolean] = None, filterOr: Option[Boolean] = None, contentMetadataId: Option[Long] = None, groupId: Option[Long] = None): Future[List[User]] = {
      helper.searchUsers(fields, page, perPage, sorts, id, firstName, lastName, verifiedLookerEmployee, email, isDisabled, filterOr, contentMetadataId, groupId)
  }

  /**
   * Search User Names
   * ### Search users where first_name OR last_name OR email matches a string.  The results will be AND&#39;d with any additional search parameters that are (optionally) included. 
   *
   * @param pattern Pattern to match. 
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param id Match User Id. (optional)
   * @param firstName Match First name. (optional)
   * @param lastName Match Last name. (optional)
   * @param verifiedLookerEmployee Match Verified Looker employee. (optional)
   * @param email Match Email Address. (optional)
   * @param isDisabled Match Is disabled. (optional)
   * @return List[User]
   */
  def searchUsersNames(pattern: String, fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None, id: Option[Long] = None, firstName: Option[String] = None, lastName: Option[String] = None, verifiedLookerEmployee: Option[Boolean] = None, email: Option[String] = None, isDisabled: Option[Boolean] = None): Option[List[User]] = {
    val await = Try(Await.result(searchUsersNamesAsync(pattern, fields, page, perPage, sorts, id, firstName, lastName, verifiedLookerEmployee, email, isDisabled), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Search User Names asynchronously
   * ### Search users where first_name OR last_name OR email matches a string.  The results will be AND&#39;d with any additional search parameters that are (optionally) included. 
   *
   * @param pattern Pattern to match. 
   * @param fields Requested fields. (optional)
   * @param page Requested page. (optional)
   * @param perPage Results per page. (optional)
   * @param sorts Fields to sort by. (optional)
   * @param id Match User Id. (optional)
   * @param firstName Match First name. (optional)
   * @param lastName Match Last name. (optional)
   * @param verifiedLookerEmployee Match Verified Looker employee. (optional)
   * @param email Match Email Address. (optional)
   * @param isDisabled Match Is disabled. (optional)
   * @return Future(List[User])
   */
  def searchUsersNamesAsync(pattern: String, fields: Option[String] = None, page: Option[Long] = None, perPage: Option[Long] = None, sorts: Option[String] = None, id: Option[Long] = None, firstName: Option[String] = None, lastName: Option[String] = None, verifiedLookerEmployee: Option[Boolean] = None, email: Option[String] = None, isDisabled: Option[Boolean] = None): Future[List[User]] = {
      helper.searchUsersNames(pattern, fields, page, perPage, sorts, id, firstName, lastName, verifiedLookerEmployee, email, isDisabled)
  }

  /**
   * Set User Attribute User Value
   * ### Store a custom value for a user attribute in a user&#39;s account settings.  Per-user user attribute values take precedence over group or default values. 
   *
   * @param userId Id of user 
   * @param userAttributeId Id of user attribute 
   * @param body New attribute value for user. 
   * @return UserAttributeWithValue
   */
  def setUserAttributeUserValue(userId: Long, userAttributeId: Long, body: UserAttributeWithValue): Option[UserAttributeWithValue] = {
    val await = Try(Await.result(setUserAttributeUserValueAsync(userId, userAttributeId, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set User Attribute User Value asynchronously
   * ### Store a custom value for a user attribute in a user&#39;s account settings.  Per-user user attribute values take precedence over group or default values. 
   *
   * @param userId Id of user 
   * @param userAttributeId Id of user attribute 
   * @param body New attribute value for user. 
   * @return Future(UserAttributeWithValue)
   */
  def setUserAttributeUserValueAsync(userId: Long, userAttributeId: Long, body: UserAttributeWithValue): Future[UserAttributeWithValue] = {
      helper.setUserAttributeUserValue(userId, userAttributeId, body)
  }

  /**
   * Set User Roles
   * ### Set roles of the user with a specific id. 
   *
   * @param userId id of user 
   * @param body array of roles ids for user 
   * @param fields Requested fields. (optional)
   * @return List[Role]
   */
  def setUserRoles(userId: Long, body: List[Long], fields: Option[String] = None): Option[List[Role]] = {
    val await = Try(Await.result(setUserRolesAsync(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set User Roles asynchronously
   * ### Set roles of the user with a specific id. 
   *
   * @param userId id of user 
   * @param body array of roles ids for user 
   * @param fields Requested fields. (optional)
   * @return Future(List[Role])
   */
  def setUserRolesAsync(userId: Long, body: List[Long], fields: Option[String] = None): Future[List[Role]] = {
      helper.setUserRoles(userId, body, fields)
  }

  /**
   * Update User
   * ### Update information about the user with a specific id. 
   *
   * @param userId Id of user 
   * @param body User 
   * @param fields Requested fields. (optional)
   * @return User
   */
  def updateUser(userId: Long, body: User, fields: Option[String] = None): Option[User] = {
    val await = Try(Await.result(updateUserAsync(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update User asynchronously
   * ### Update information about the user with a specific id. 
   *
   * @param userId Id of user 
   * @param body User 
   * @param fields Requested fields. (optional)
   * @return Future(User)
   */
  def updateUserAsync(userId: Long, body: User, fields: Option[String] = None): Future[User] = {
      helper.updateUser(userId, body, fields)
  }

  /**
   * Update Access Filter
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param accessFilterId id of Access Filter 
   * @param body Access Filter 
   * @param fields Requested fields. (optional)
   * @return AccessFilter
   */
  def updateUserAccessFilter(userId: Long, accessFilterId: Long, body: AccessFilter, fields: Option[String] = None): Option[AccessFilter] = {
    val await = Try(Await.result(updateUserAccessFilterAsync(userId, accessFilterId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Access Filter asynchronously
   * ### Access filter for the specified user.
   *
   * @param userId id of user 
   * @param accessFilterId id of Access Filter 
   * @param body Access Filter 
   * @param fields Requested fields. (optional)
   * @return Future(AccessFilter)
   */
  def updateUserAccessFilterAsync(userId: Long, accessFilterId: Long, body: AccessFilter, fields: Option[String] = None): Future[AccessFilter] = {
      helper.updateUserAccessFilter(userId, accessFilterId, body, fields)
  }

  /**
   * Update Email/Password Credential
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @param body Email/Password Credential 
   * @param fields Requested fields. (optional)
   * @return CredentialsEmail
   */
  def updateUserCredentialsEmail(userId: Long, body: CredentialsEmail, fields: Option[String] = None): Option[CredentialsEmail] = {
    val await = Try(Await.result(updateUserCredentialsEmailAsync(userId, body, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update Email/Password Credential asynchronously
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @param body Email/Password Credential 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsEmail)
   */
  def updateUserCredentialsEmailAsync(userId: Long, body: CredentialsEmail, fields: Option[String] = None): Future[CredentialsEmail] = {
      helper.updateUserCredentialsEmail(userId, body, fields)
  }

  /**
   * Get User by Id
   * ### Get information about the user with a specific id.  If the caller is an admin or the caller is the user being specified, then full user information will be returned. Otherwise, a minimal &#39;public&#39; variant of the user information will be returned. This contains The user name and avatar url, but no sensitive information. 
   *
   * @param userId Id of user 
   * @param fields Requested fields. (optional)
   * @return User
   */
  def user(userId: Long, fields: Option[String] = None): Option[User] = {
    val await = Try(Await.result(userAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get User by Id asynchronously
   * ### Get information about the user with a specific id.  If the caller is an admin or the caller is the user being specified, then full user information will be returned. Otherwise, a minimal &#39;public&#39; variant of the user information will be returned. This contains The user name and avatar url, but no sensitive information. 
   *
   * @param userId Id of user 
   * @param fields Requested fields. (optional)
   * @return Future(User)
   */
  def userAsync(userId: Long, fields: Option[String] = None): Future[User] = {
      helper.user(userId, fields)
  }

  /**
   * Get Access Filter
   * ### Access filter for the specified user.
   *
   * @param userId Id of user 
   * @param accessFilterId Id of Access Filter 
   * @param fields Requested fields. (optional)
   * @return AccessFilter
   */
  def userAccessFilter(userId: Long, accessFilterId: Long, fields: Option[String] = None): Option[AccessFilter] = {
    val await = Try(Await.result(userAccessFilterAsync(userId, accessFilterId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Access Filter asynchronously
   * ### Access filter for the specified user.
   *
   * @param userId Id of user 
   * @param accessFilterId Id of Access Filter 
   * @param fields Requested fields. (optional)
   * @return Future(AccessFilter)
   */
  def userAccessFilterAsync(userId: Long, accessFilterId: Long, fields: Option[String] = None): Future[AccessFilter] = {
      helper.userAccessFilter(userId, accessFilterId, fields)
  }

  /**
   * Get User Attribute Values
   * ### Get user attribute values for a given user.  Returns the values of specified user attributes (or all user attributes) for a certain user.  A value for each user attribute is searched for in the following locations, in this order: 1. in the user&#39;s account information 1. in groups that the user is a member of 1. the default value of the user attribute  If more than one group has a value defined for a user attribute, the group with the lowest rank wins.  The response will only include user attributes for which values were found. Use &#x60;include_unset&#x3D;true&#x60; to include empty records for user attributes with no value.  The value of all hidden user attributes will be blank. 
   *
   * @param userId Id of user 
   * @param fields Requested fields. (optional)
   * @param userAttributeIds Specific user attributes to request. Omit or leave blank to request all user attributes. (optional)
   * @param allValues If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence. (optional)
   * @param includeUnset If true, returns an empty record for each requested attribute that has no user, group, or default value. (optional)
   * @return List[UserAttributeWithValue]
   */
  def userAttributeUserValues(userId: Long, fields: Option[String] = None, userAttributeIds: Option[List[Long]] = None, allValues: Option[Boolean] = None, includeUnset: Option[Boolean] = None): Option[List[UserAttributeWithValue]] = {
    val await = Try(Await.result(userAttributeUserValuesAsync(userId, fields, userAttributeIds, allValues, includeUnset), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get User Attribute Values asynchronously
   * ### Get user attribute values for a given user.  Returns the values of specified user attributes (or all user attributes) for a certain user.  A value for each user attribute is searched for in the following locations, in this order: 1. in the user&#39;s account information 1. in groups that the user is a member of 1. the default value of the user attribute  If more than one group has a value defined for a user attribute, the group with the lowest rank wins.  The response will only include user attributes for which values were found. Use &#x60;include_unset&#x3D;true&#x60; to include empty records for user attributes with no value.  The value of all hidden user attributes will be blank. 
   *
   * @param userId Id of user 
   * @param fields Requested fields. (optional)
   * @param userAttributeIds Specific user attributes to request. Omit or leave blank to request all user attributes. (optional)
   * @param allValues If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence. (optional)
   * @param includeUnset If true, returns an empty record for each requested attribute that has no user, group, or default value. (optional)
   * @return Future(List[UserAttributeWithValue])
   */
  def userAttributeUserValuesAsync(userId: Long, fields: Option[String] = None, userAttributeIds: Option[List[Long]] = None, allValues: Option[Boolean] = None, includeUnset: Option[Boolean] = None): Future[List[UserAttributeWithValue]] = {
      helper.userAttributeUserValues(userId, fields, userAttributeIds, allValues, includeUnset)
  }

  /**
   * Get API Credential
   * ### API login information for the specified user. This is for &#39;API Users&#39; used for the &#39;old&#39; query API. THIS SUPPORT HAS BEEN REMOVED.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsApi
   */
  def userCredentialsApi(userId: Long, fields: Option[String] = None): Option[CredentialsApi] = {
    val await = Try(Await.result(userCredentialsApiAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get API Credential asynchronously
   * ### API login information for the specified user. This is for &#39;API Users&#39; used for the &#39;old&#39; query API. THIS SUPPORT HAS BEEN REMOVED.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsApi)
   */
  def userCredentialsApiAsync(userId: Long, fields: Option[String] = None): Future[CredentialsApi] = {
      helper.userCredentialsApi(userId, fields)
  }

  /**
   * Get API 3 Credential
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId Id of user 
   * @param credentialsApi3Id Id of API 3 Credential 
   * @param fields Requested fields. (optional)
   * @return CredentialsApi3
   */
  def userCredentialsApi3(userId: Long, credentialsApi3Id: Long, fields: Option[String] = None): Option[CredentialsApi3] = {
    val await = Try(Await.result(userCredentialsApi3Async(userId, credentialsApi3Id, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get API 3 Credential asynchronously
   * ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.
   *
   * @param userId Id of user 
   * @param credentialsApi3Id Id of API 3 Credential 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsApi3)
   */
  def userCredentialsApi3Async(userId: Long, credentialsApi3Id: Long, fields: Option[String] = None): Future[CredentialsApi3] = {
      helper.userCredentialsApi3(userId, credentialsApi3Id, fields)
  }

  /**
   * Get Email/Password Credential
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsEmail
   */
  def userCredentialsEmail(userId: Long, fields: Option[String] = None): Option[CredentialsEmail] = {
    val await = Try(Await.result(userCredentialsEmailAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Email/Password Credential asynchronously
   * ### Email/password login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsEmail)
   */
  def userCredentialsEmailAsync(userId: Long, fields: Option[String] = None): Future[CredentialsEmail] = {
      helper.userCredentialsEmail(userId, fields)
  }

  /**
   * Get Embedding Credential
   * ### Embed login information for the specified user.
   *
   * @param userId Id of user 
   * @param credentialsEmbedId Id of Embedding Credential 
   * @param fields Requested fields. (optional)
   * @return CredentialsEmbed
   */
  def userCredentialsEmbed(userId: Long, credentialsEmbedId: Long, fields: Option[String] = None): Option[CredentialsEmbed] = {
    val await = Try(Await.result(userCredentialsEmbedAsync(userId, credentialsEmbedId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Embedding Credential asynchronously
   * ### Embed login information for the specified user.
   *
   * @param userId Id of user 
   * @param credentialsEmbedId Id of Embedding Credential 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsEmbed)
   */
  def userCredentialsEmbedAsync(userId: Long, credentialsEmbedId: Long, fields: Option[String] = None): Future[CredentialsEmbed] = {
      helper.userCredentialsEmbed(userId, credentialsEmbedId, fields)
  }

  /**
   * Get Google Auth Credential
   * ### Google authentication login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsGoogle
   */
  def userCredentialsGoogle(userId: Long, fields: Option[String] = None): Option[CredentialsGoogle] = {
    val await = Try(Await.result(userCredentialsGoogleAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Google Auth Credential asynchronously
   * ### Google authentication login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsGoogle)
   */
  def userCredentialsGoogleAsync(userId: Long, fields: Option[String] = None): Future[CredentialsGoogle] = {
      helper.userCredentialsGoogle(userId, fields)
  }

  /**
   * Get LDAP Credential
   * ### LDAP login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsLDAP
   */
  def userCredentialsLdap(userId: Long, fields: Option[String] = None): Option[CredentialsLDAP] = {
    val await = Try(Await.result(userCredentialsLdapAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get LDAP Credential asynchronously
   * ### LDAP login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsLDAP)
   */
  def userCredentialsLdapAsync(userId: Long, fields: Option[String] = None): Future[CredentialsLDAP] = {
      helper.userCredentialsLdap(userId, fields)
  }

  /**
   * Get Looker OpenId Credential
   * ### Looker Openid login information for the specified user. Used by Looker Analysts.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsLookerOpenid
   */
  def userCredentialsLookerOpenid(userId: Long, fields: Option[String] = None): Option[CredentialsLookerOpenid] = {
    val await = Try(Await.result(userCredentialsLookerOpenidAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Looker OpenId Credential asynchronously
   * ### Looker Openid login information for the specified user. Used by Looker Analysts.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsLookerOpenid)
   */
  def userCredentialsLookerOpenidAsync(userId: Long, fields: Option[String] = None): Future[CredentialsLookerOpenid] = {
      helper.userCredentialsLookerOpenid(userId, fields)
  }

  /**
   * Get OIDC Auth Credential
   * ### OpenID Connect (OIDC) authentication login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsOIDC
   */
  def userCredentialsOidc(userId: Long, fields: Option[String] = None): Option[CredentialsOIDC] = {
    val await = Try(Await.result(userCredentialsOidcAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get OIDC Auth Credential asynchronously
   * ### OpenID Connect (OIDC) authentication login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsOIDC)
   */
  def userCredentialsOidcAsync(userId: Long, fields: Option[String] = None): Future[CredentialsOIDC] = {
      helper.userCredentialsOidc(userId, fields)
  }

  /**
   * Get Saml Auth Credential
   * ### Saml authentication login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsSaml
   */
  def userCredentialsSaml(userId: Long, fields: Option[String] = None): Option[CredentialsSaml] = {
    val await = Try(Await.result(userCredentialsSamlAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Saml Auth Credential asynchronously
   * ### Saml authentication login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsSaml)
   */
  def userCredentialsSamlAsync(userId: Long, fields: Option[String] = None): Future[CredentialsSaml] = {
      helper.userCredentialsSaml(userId, fields)
  }

  /**
   * Get Two-Factor Credential
   * ### Two-factor login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return CredentialsTotp
   */
  def userCredentialsTotp(userId: Long, fields: Option[String] = None): Option[CredentialsTotp] = {
    val await = Try(Await.result(userCredentialsTotpAsync(userId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Two-Factor Credential asynchronously
   * ### Two-factor login information for the specified user.
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @return Future(CredentialsTotp)
   */
  def userCredentialsTotpAsync(userId: Long, fields: Option[String] = None): Future[CredentialsTotp] = {
      helper.userCredentialsTotp(userId, fields)
  }

  /**
   * Get User by Credential Id
   * ### Get information about the user with a credential of given type with specific id.  This is used to do things like find users by their embed external_user_id. Or, find the user with a given api3 client_id, etc. The &#39;credential_type&#39; matchs the &#39;type&#39; name of the various credential types. It must be one of the values listed in the table below. The &#39;credential_id&#39; is your unique Id for the user and is specific to each type of credential.  An example using the Ruby sdk might look like:  &#x60;sdk.user_for_credential(&#39;embed&#39;, &#39;customer-4959425&#39;)&#x60;  This table shows the supported &#39;Credential Type&#39; strings. The right column is for reference; it shows which field in the given credential type is actually searched when finding a user with the supplied &#39;credential_id&#39;.  | Credential Types | Id Field Matched | | ---------------- | ---------------- | | email            | email            | | google           | google_user_id   | | saml             | saml_user_id     | | oidc             | oidc_user_id     | | ldap             | ldap_id          | | api              | token            | | api3             | client_id        | | embed            | external_user_id | | looker_openid    | email            |  NOTE: &#39;api&#39; is the legacy Looker query API. The API you are currently looking at is &#39;api3&#39;.  
   *
   * @param credentialType Type name of credential 
   * @param credentialId Id of credential 
   * @param fields Requested fields. (optional)
   * @return User
   */
  def userForCredential(credentialType: String, credentialId: String, fields: Option[String] = None): Option[User] = {
    val await = Try(Await.result(userForCredentialAsync(credentialType, credentialId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get User by Credential Id asynchronously
   * ### Get information about the user with a credential of given type with specific id.  This is used to do things like find users by their embed external_user_id. Or, find the user with a given api3 client_id, etc. The &#39;credential_type&#39; matchs the &#39;type&#39; name of the various credential types. It must be one of the values listed in the table below. The &#39;credential_id&#39; is your unique Id for the user and is specific to each type of credential.  An example using the Ruby sdk might look like:  &#x60;sdk.user_for_credential(&#39;embed&#39;, &#39;customer-4959425&#39;)&#x60;  This table shows the supported &#39;Credential Type&#39; strings. The right column is for reference; it shows which field in the given credential type is actually searched when finding a user with the supplied &#39;credential_id&#39;.  | Credential Types | Id Field Matched | | ---------------- | ---------------- | | email            | email            | | google           | google_user_id   | | saml             | saml_user_id     | | oidc             | oidc_user_id     | | ldap             | ldap_id          | | api              | token            | | api3             | client_id        | | embed            | external_user_id | | looker_openid    | email            |  NOTE: &#39;api&#39; is the legacy Looker query API. The API you are currently looking at is &#39;api3&#39;.  
   *
   * @param credentialType Type name of credential 
   * @param credentialId Id of credential 
   * @param fields Requested fields. (optional)
   * @return Future(User)
   */
  def userForCredentialAsync(credentialType: String, credentialId: String, fields: Option[String] = None): Future[User] = {
      helper.userForCredential(credentialType, credentialId, fields)
  }

  /**
   * Get User Roles
   * ### Get information about roles of the user with a specific id. 
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @param directAssociationOnly Get only roles associated directly with the user: exclude those only associated through groups. (optional)
   * @return List[Role]
   */
  def userRoles(userId: Long, fields: Option[String] = None, directAssociationOnly: Option[Boolean] = None): Option[List[Role]] = {
    val await = Try(Await.result(userRolesAsync(userId, fields, directAssociationOnly), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get User Roles asynchronously
   * ### Get information about roles of the user with a specific id. 
   *
   * @param userId id of user 
   * @param fields Requested fields. (optional)
   * @param directAssociationOnly Get only roles associated directly with the user: exclude those only associated through groups. (optional)
   * @return Future(List[Role])
   */
  def userRolesAsync(userId: Long, fields: Option[String] = None, directAssociationOnly: Option[Boolean] = None): Future[List[Role]] = {
      helper.userRoles(userId, fields, directAssociationOnly)
  }

  /**
   * Get Web Login Session
   * ### Web login session for the specified user.
   *
   * @param userId Id of user 
   * @param sessionId Id of Web Login Session 
   * @param fields Requested fields. (optional)
   * @return Session
   */
  def userSession(userId: Long, sessionId: Long, fields: Option[String] = None): Option[Session] = {
    val await = Try(Await.result(userSessionAsync(userId, sessionId, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get Web Login Session asynchronously
   * ### Web login session for the specified user.
   *
   * @param userId Id of user 
   * @param sessionId Id of Web Login Session 
   * @param fields Requested fields. (optional)
   * @return Future(Session)
   */
  def userSessionAsync(userId: Long, sessionId: Long, fields: Option[String] = None): Future[Session] = {
      helper.userSession(userId, sessionId, fields)
  }

}

class UserApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def allUserAccessFilters(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[AccessFilter]]): Future[List[AccessFilter]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/access_filters")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allUserCredentialsApi3s(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[CredentialsApi3]]): Future[List[CredentialsApi3]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api3")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allUserCredentialsEmbeds(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[CredentialsEmbed]]): Future[List[CredentialsEmbed]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_embed")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allUserSessions(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Session]]): Future[List[Session]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/sessions")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def allUsers(fields: Option[String] = None,
    page: Option[Long] = None,
    perPage: Option[Long] = None,
    sorts: Option[String] = None,
    ids: Option[List[Long]] = None
    )(implicit reader: ClientResponseReader[List[User]]): Future[List[User]] = {
    // create path and map variables
    val path = (addFmt("/users"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    perPage match {
      case Some(param) => queryParams += "per_page" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }
    ids match {
      case Some(param) => queryParams += "ids" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUser(body: Option[User] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[User], writer: RequestWriter[Option[User]]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/users"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserAccessFilter(userId: Long,
    body: Option[AccessFilter] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[AccessFilter], writer: RequestWriter[Option[AccessFilter]]): Future[AccessFilter] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/access_filters")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserCredentialsApi(userId: Long,
    body: Option[CredentialsApi] = None
    )(implicit reader: ClientResponseReader[CredentialsApi], writer: RequestWriter[Option[CredentialsApi]]): Future[CredentialsApi] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserCredentialsApi3(userId: Long,
    body: Option[CredentialsApi3] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsApi3], writer: RequestWriter[Option[CredentialsApi3]]): Future[CredentialsApi3] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api3")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserCredentialsEmail(userId: Long,
    body: Option[CredentialsEmail] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsEmail], writer: RequestWriter[Option[CredentialsEmail]]): Future[CredentialsEmail] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_email")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserCredentialsEmailPasswordReset(userId: Long,
    expires: Option[Boolean] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsEmail]): Future[CredentialsEmail] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_email/password_reset")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    expires match {
      case Some(param) => queryParams += "expires" -> param.toString
      case _ => queryParams
    }
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createUserCredentialsTotp(userId: Long,
    body: Option[CredentialsTotp] = None,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsTotp], writer: RequestWriter[Option[CredentialsTotp]]): Future[CredentialsTotp] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_totp")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUser(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserAccessFilter(userId: Long,
    accessFilterId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/access_filters/{access_filter_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "access_filter_id" + "\\}", accessFilterId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserAttributeUserValue(userId: Long,
    userAttributeId: Long)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/attribute_values/{user_attribute_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "user_attribute_id" + "\\}", userAttributeId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsApi(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsApi3(userId: Long,
    credentialsApi3Id: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api3/{credentials_api3_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "credentials_api3_id" + "\\}", credentialsApi3Id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsEmail(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_email")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsEmbed(userId: Long,
    credentialsEmbedId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_embed/{credentials_embed_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "credentials_embed_id" + "\\}", credentialsEmbedId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsGoogle(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_google")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsLdap(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_ldap")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsLookerOpenid(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_looker_openid")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsOidc(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_oidc")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsSaml(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_saml")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserCredentialsTotp(userId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_totp")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteUserSession(userId: Long,
    sessionId: Long)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/sessions/{session_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "session_id" + "\\}", sessionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def me(fields: Option[String] = None
    )(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/user"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def searchUsers(fields: Option[String] = None,
    page: Option[Long] = None,
    perPage: Option[Long] = None,
    sorts: Option[String] = None,
    id: Option[Long] = None,
    firstName: Option[String] = None,
    lastName: Option[String] = None,
    verifiedLookerEmployee: Option[Boolean] = None,
    email: Option[String] = None,
    isDisabled: Option[Boolean] = None,
    filterOr: Option[Boolean] = None,
    contentMetadataId: Option[Long] = None,
    groupId: Option[Long] = None
    )(implicit reader: ClientResponseReader[List[User]]): Future[List[User]] = {
    // create path and map variables
    val path = (addFmt("/users/search"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    perPage match {
      case Some(param) => queryParams += "per_page" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }
    id match {
      case Some(param) => queryParams += "id" -> param.toString
      case _ => queryParams
    }
    firstName match {
      case Some(param) => queryParams += "first_name" -> param.toString
      case _ => queryParams
    }
    lastName match {
      case Some(param) => queryParams += "last_name" -> param.toString
      case _ => queryParams
    }
    verifiedLookerEmployee match {
      case Some(param) => queryParams += "verified_looker_employee" -> param.toString
      case _ => queryParams
    }
    email match {
      case Some(param) => queryParams += "email" -> param.toString
      case _ => queryParams
    }
    isDisabled match {
      case Some(param) => queryParams += "is_disabled" -> param.toString
      case _ => queryParams
    }
    filterOr match {
      case Some(param) => queryParams += "filter_or" -> param.toString
      case _ => queryParams
    }
    contentMetadataId match {
      case Some(param) => queryParams += "content_metadata_id" -> param.toString
      case _ => queryParams
    }
    groupId match {
      case Some(param) => queryParams += "group_id" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def searchUsersNames(pattern: String,
    fields: Option[String] = None,
    page: Option[Long] = None,
    perPage: Option[Long] = None,
    sorts: Option[String] = None,
    id: Option[Long] = None,
    firstName: Option[String] = None,
    lastName: Option[String] = None,
    verifiedLookerEmployee: Option[Boolean] = None,
    email: Option[String] = None,
    isDisabled: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[List[User]]): Future[List[User]] = {
    // create path and map variables
    val path = (addFmt("/users/search/names/{pattern}")
      replaceAll("\\{" + "pattern" + "\\}", pattern.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (pattern == null) throw new Exception("Missing required parameter 'pattern' when calling UserApi->searchUsersNames")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    perPage match {
      case Some(param) => queryParams += "per_page" -> param.toString
      case _ => queryParams
    }
    sorts match {
      case Some(param) => queryParams += "sorts" -> param.toString
      case _ => queryParams
    }
    id match {
      case Some(param) => queryParams += "id" -> param.toString
      case _ => queryParams
    }
    firstName match {
      case Some(param) => queryParams += "first_name" -> param.toString
      case _ => queryParams
    }
    lastName match {
      case Some(param) => queryParams += "last_name" -> param.toString
      case _ => queryParams
    }
    verifiedLookerEmployee match {
      case Some(param) => queryParams += "verified_looker_employee" -> param.toString
      case _ => queryParams
    }
    email match {
      case Some(param) => queryParams += "email" -> param.toString
      case _ => queryParams
    }
    isDisabled match {
      case Some(param) => queryParams += "is_disabled" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setUserAttributeUserValue(userId: Long,
    userAttributeId: Long,
    body: UserAttributeWithValue)(implicit reader: ClientResponseReader[UserAttributeWithValue], writer: RequestWriter[UserAttributeWithValue]): Future[UserAttributeWithValue] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/attribute_values/{user_attribute_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "user_attribute_id" + "\\}", userAttributeId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling UserApi->setUserAttributeUserValue")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setUserRoles(userId: Long,
    body: List[Long],
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[List[Role]], writer: RequestWriter[List[Long]]): Future[List[Role]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/roles")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUser(userId: Long,
    body: User,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[User], writer: RequestWriter[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling UserApi->updateUser")
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUserAccessFilter(userId: Long,
    accessFilterId: Long,
    body: AccessFilter,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[AccessFilter], writer: RequestWriter[AccessFilter]): Future[AccessFilter] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/access_filters/{access_filter_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "access_filter_id" + "\\}", accessFilterId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling UserApi->updateUserAccessFilter")
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateUserCredentialsEmail(userId: Long,
    body: CredentialsEmail,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsEmail], writer: RequestWriter[CredentialsEmail]): Future[CredentialsEmail] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_email")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling UserApi->updateUserCredentialsEmail")
    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def user(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userAccessFilter(userId: Long,
    accessFilterId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[AccessFilter]): Future[AccessFilter] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/access_filters/{access_filter_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "access_filter_id" + "\\}", accessFilterId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userAttributeUserValues(userId: Long,
    fields: Option[String] = None,
    userAttributeIds: Option[List[Long]] = None,
    allValues: Option[Boolean] = None,
    includeUnset: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[List[UserAttributeWithValue]]): Future[List[UserAttributeWithValue]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/attribute_values")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    userAttributeIds match {
      case Some(param) => queryParams += "user_attribute_ids" -> param.toString
      case _ => queryParams
    }
    allValues match {
      case Some(param) => queryParams += "all_values" -> param.toString
      case _ => queryParams
    }
    includeUnset match {
      case Some(param) => queryParams += "include_unset" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsApi(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsApi]): Future[CredentialsApi] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsApi3(userId: Long,
    credentialsApi3Id: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsApi3]): Future[CredentialsApi3] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_api3/{credentials_api3_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "credentials_api3_id" + "\\}", credentialsApi3Id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsEmail(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsEmail]): Future[CredentialsEmail] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_email")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsEmbed(userId: Long,
    credentialsEmbedId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsEmbed]): Future[CredentialsEmbed] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_embed/{credentials_embed_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "credentials_embed_id" + "\\}", credentialsEmbedId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsGoogle(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsGoogle]): Future[CredentialsGoogle] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_google")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsLdap(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsLDAP]): Future[CredentialsLDAP] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_ldap")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsLookerOpenid(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsLookerOpenid]): Future[CredentialsLookerOpenid] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_looker_openid")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsOidc(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsOIDC]): Future[CredentialsOIDC] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_oidc")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsSaml(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsSaml]): Future[CredentialsSaml] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_saml")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userCredentialsTotp(userId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[CredentialsTotp]): Future[CredentialsTotp] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/credentials_totp")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userForCredential(credentialType: String,
    credentialId: String,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/users/credential/{credential_type}/{credential_id}")
      replaceAll("\\{" + "credential_type" + "\\}", credentialType.toString)
      replaceAll("\\{" + "credential_id" + "\\}", credentialId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (credentialType == null) throw new Exception("Missing required parameter 'credentialType' when calling UserApi->userForCredential")

    if (credentialId == null) throw new Exception("Missing required parameter 'credentialId' when calling UserApi->userForCredential")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userRoles(userId: Long,
    fields: Option[String] = None,
    directAssociationOnly: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[List[Role]]): Future[List[Role]] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/roles")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }
    directAssociationOnly match {
      case Some(param) => queryParams += "direct_association_only" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userSession(userId: Long,
    sessionId: Long,
    fields: Option[String] = None
    )(implicit reader: ClientResponseReader[Session]): Future[Session] = {
    // create path and map variables
    val path = (addFmt("/users/{user_id}/sessions/{session_id}")
      replaceAll("\\{" + "user_id" + "\\}", userId.toString)
      replaceAll("\\{" + "session_id" + "\\}", sessionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
